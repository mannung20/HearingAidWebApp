<!DOCTYPE html>
<html>
<head>
<title>ë³´ì²­ê¸° ì›¹ì•±</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; min-height: 100vh; display: flex; align-items: center; justify-content: center; }
.container { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15); max-width: 400px; width: 100%; text-align: center; }
h1 { color: #333; margin-bottom: 30px; font-size: 1.8em; }
.permission-guide { background: #fff3cd; color: #856404; padding: 15px; border-radius: 10px; margin-bottom: 20px; font-size: 14px; display: none; }
.controls { margin-bottom: 30px; }
button { background: #4CAF50; color: white; border: none; padding: 15px 30px; margin: 10px; border-radius: 25px; font-size: 16px; cursor: pointer; transition: all 0.3s; min-width: 120px; font-weight: bold; }
button:hover { transform: translateY(-2px); }
button:disabled { background: #cccccc; cursor: not-allowed; transform: none; }
.permission-btn { background: #2196F3; }
#stopButton { background: #f44336; }
.volume-control { margin-bottom: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
.volume-control label { display: block; margin-bottom: 15px; font-weight: bold; color: #333; font-size: 1.1em; }
#volumeSlider { width: 100%; height: 8px; background: #ddd; outline: none; border-radius: 5px; margin-bottom: 15px; }
#volumeSlider::-webkit-slider-thumb { appearance: none; width: 25px; height: 25px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
#volumeDisplay { font-size: 1.5em; font-weight: bold; color: #4CAF50; }
#status { padding: 15px; border-radius: 8px; font-weight: bold; background: #e8f5e8; color: #2e7d2e; margin-top: 20px; font-size: 1.1em; }
@media (max-width: 480px) { body { padding: 10px; } .container { padding: 20px; } h1 { font-size: 1.5em; } button { padding: 12px 20px; font-size: 14px; margin: 5px; } }
</style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”Š ë³´ì²­ê¸° ì›¹ì•±</h1>
    
    <div id="permissionGuide" class="permission-guide">
      <strong>ğŸ“± ë§ˆì´í¬ ê¶Œí•œ í—ˆìš© ë°©ë²•:</strong><br>
      1. ì£¼ì†Œì°½ ì¢Œì¸¡ ğŸ”’ ì•„ì´ì½˜ í´ë¦­<br>
      2. "ë§ˆì´í¬" â†’ "í—ˆìš©" ì„ íƒ<br>
      3. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„
    </div>
    
    <div class="controls">
      <button id="permissionBtn" class="permission-btn">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
      <button id="startButton">ì‹œì‘</button>
      <button id="stopButton">ì •ì§€</button>
    </div>
    
    <div class="volume-control">
      <label for="volumeSlider">ë³¼ë¥¨:</label>
      <input type="range" id="volumeSlider" min="0" max="100" value="50">
      <span id="volumeDisplay">50</span>%
    </div>
    
    <div id="status">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œì„ ìš”ì²­í•´ì£¼ì„¸ìš”</div>
  </div>

<script>
const permissionBtn = document.getElementById('permissionBtn');
const startButton = document.getElementById('startButton');
const stopButton = document.getElementById('stopButton');
const volumeSlider = document.getElementById('volumeSlider');
const volumeDisplay = document.getElementById('volumeDisplay');
const statusDiv = document.getElementById('status');
const permissionGuide = document.getElementById('permissionGuide');

let audioContext, microphoneStream, gainNode, highpassFilter, source, isRunning = false;
let hasPermission = false;
let wakeLock = null;
let wasRunningBeforeHidden = false;

// ì´ˆê¸° ìƒíƒœ ì„¤ì •
startButton.disabled = true;
stopButton.disabled = true;

// 1ë‹¨ê³„: ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­
permissionBtn.addEventListener('click', async () => {
  try {
    statusDiv.textContent = 'ğŸ”„ ë§ˆì´í¬ ê¶Œí•œ í™•ì¸ ì¤‘...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    
    // ê¶Œí•œ ì„±ê³µ - ì„ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
    stream.getTracks().forEach(track => track.stop());
    hasPermission = true;
    
    statusDiv.textContent = 'âœ… ë§ˆì´í¬ ê¶Œí•œ í—ˆìš©ë¨ - ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    permissionBtn.disabled = true;
    startButton.disabled = false;
    permissionGuide.style.display = 'none';
    
  } catch (err) {
    let errorMessage = 'âŒ ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨: ';
    if (err.name === 'NotAllowedError') {
      errorMessage += 'ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
    } else if (err.name === 'NotFoundError') {
      errorMessage += 'ë§ˆì´í¬ ì¥ì¹˜ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += 'ì§€ì›ë˜ì§€ ì•ŠëŠ” ë§ˆì´í¬ ì„¤ì •ì…ë‹ˆë‹¤.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('ê¶Œí•œ ì˜¤ë¥˜:', err);
  }
});

// 2ë‹¨ê³„: ë³´ì²­ê¸° ì‹œì‘
startButton.addEventListener('click', async () => {
  try {
    statusDiv.textContent = 'ğŸš€ ë³´ì²­ê¸° ì‹œì‘ ì¤‘...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    microphoneStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    console.log("AudioContext state:", audioContext.state); 
    if (audioContext.state === 'suspended') {
        await audioContext.resume();
        console.log("AudioContext resumed"); 
    }

    source = audioContext.createMediaStreamSource(microphoneStream);
    gainNode = audioContext.createGain();
    highpassFilter = audioContext.createBiquadFilter();
    highpassFilter.type = 'highpass';
    highpassFilter.frequency.setValueAtTime(100, audioContext.currentTime); 

    const volume = volumeSlider.value / 100;
    gainNode.gain.value = volume * 2;

    source.connect(highpassFilter);
    highpassFilter.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    startButton.disabled = true;
    stopButton.disabled = false;
    isRunning = true;
    
    statusDiv.textContent = 'ğŸ”Š ë³´ì²­ê¸° ì‘ë™ ì¤‘ (ì´ì–´í° ì°©ìš© ê¶Œì¥)';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    // Wake Lock API ì‚¬ìš© (ì§€ì›í•˜ëŠ” ë¸Œë¼ìš°ì €ì—ì„œ)
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock acquired');
      } catch (err) {
        console.error('Wake Lock request failed:', err);
      }
    }

  } catch (err) {
    let errorMessage = 'âŒ ë³´ì²­ê¸° ì‹œì‘ ì‹¤íŒ¨: ';
    if (err.name === 'NotAllowedError') {
        errorMessage += 'ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
    } else if (err.name === 'NotFoundError'){
        errorMessage += 'AudioContextê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += 'ì§€ì›ë˜ì§€ ì•ŠëŠ” ë§ˆì´í¬ ì„¤ì •ì…ë‹ˆë‹¤.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('ë³´ì²­ê¸° ì‹œì‘ ì˜¤ë¥˜:', err);
  }
});

// 3ë‹¨ê³„: ë³´ì²­ê¸° ì •ì§€ (ìˆ˜ì •ë¨ - suspend ì‚¬ìš©)
stopButton.addEventListener('click', async () => {
  // ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
    microphoneStream = null;
  }
  
  // ì˜¤ë””ì˜¤ ë…¸ë“œë“¤ ëª…ì‹œì  í•´ì œ
  if (source) {
    source.disconnect();
    source = null;
  }
  if (gainNode) {
    gainNode.disconnect();
    gainNode = null;
  }
  if (highpassFilter) {
    highpassFilter.disconnect();
    highpassFilter = null;
  }
  
  // AudioContext suspend (ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡)
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
      console.log('AudioContext suspended (reusable)');
    } catch (err) {
      console.error('AudioContext suspend failed:', err);
    }
  }
  
  // Wake Lock í•´ì œ
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock released');
  }
  
  startButton.disabled = false;
  stopButton.disabled = true;
  isRunning = false;
  
  statusDiv.textContent = 'â¹ï¸ ë³´ì²­ê¸° ì •ì§€ë¨ (ì¬ì‹œì‘ ê°€ëŠ¥)';
  statusDiv.style.background = '#f8d7da';
  statusDiv.style.color = '#721c24';
});

// ë³¼ë¥¨ ì¡°ì ˆ
volumeSlider.addEventListener('input', function() {
  const volume = this.value / 100;
  volumeDisplay.textContent = this.value;
  
  if (gainNode && isRunning) {
    gainNode.gain.value = volume * 2;
  }
});

// Page Visibility API (ê°œì„ ë¨)
document.addEventListener('visibilitychange', async () => {
  if (document.hidden && isRunning) {
    // ë°±ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ ì‹œ ì¼ì‹œì •ì§€
    wasRunningBeforeHidden = true;
    if (audioContext && audioContext.state === 'running') {
      try {
        await audioContext.suspend();
        console.log('AudioContext suspended (background)');
        statusDiv.textContent = 'â¸ï¸ ë°±ê·¸ë¼ìš´ë“œ ì¼ì‹œì •ì§€ ì¤‘...';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      } catch (err) {
        console.error('Background suspend failed:', err);
      }
    }
  } else if (!document.hidden && wasRunningBeforeHidden && isRunning) {
    // í¬ê·¸ë¼ìš´ë“œë¡œ ë³µê·€ ì‹œ ì¬ê°œ
    if (audioContext && audioContext.state === 'suspended') {
      try {
        await audioContext.resume();
        console.log('AudioContext resumed (foreground)');
        statusDiv.textContent = 'ğŸ”Š ë³´ì²­ê¸° ì‘ë™ ì¤‘ (ì´ì–´í° ì°©ìš© ê¶Œì¥)';
        statusDiv.style.background = '#d4edda';
        statusDiv.style.color = '#155724';
      } catch (err) {
        console.error('Foreground resume failed:', err);
      }
    }
    wasRunningBeforeHidden = false;
  }
});

// ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ
async function checkAudioHealth() {
  if (isRunning && audioContext) {
    if (audioContext.state === 'suspended') {
      console.log('AudioContext suspended, attempting resume...');
      try {
        await audioContext.resume();
        console.log('AudioContext resumed successfully');
      } catch (err) {
        console.error('Failed to resume AudioContext:', err);
        statusDiv.textContent = 'âš ï¸ ì—°ê²° ë³µêµ¬ ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      }
    }
  }
}

// 5ì´ˆë§ˆë‹¤ ìƒíƒœ ì²´í¬
setInterval(checkAudioHealth, 5000);

// í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬ (ê°œì„ ë¨)
window.addEventListener('beforeunload', async () => {
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
  }
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
    } catch (err) {
      console.error('Beforeunload suspend failed:', err);
    }
  }
  if (wakeLock) {
    wakeLock.release();
  }
});

// ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìë™ ì¬ê°œ (ê°œì„ ë¨)
let resumeAudioContext = async () => {
  if (audioContext && audioContext.state === 'suspended') {
    try {
      await audioContext.resume();
    } catch (err) {
      console.error("AudioContext resume failed:", err);
    }
  }
}

document.addEventListener('click', resumeAudioContext);
document.addEventListener('touchstart', resumeAudioContext); // ëª¨ë°”ì¼ ì§€ì›
</script>
</body>
</html>