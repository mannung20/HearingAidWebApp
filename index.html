<!DOCTYPE html>
<html>
<head>
<title>보청기 웹앱</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; min-height: 100vh; display: flex; align-items: center; justify-content: center; }
.container { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15); max-width: 400px; width: 100%; text-align: center; }
h1 { color: #333; margin-bottom: 30px; font-size: 1.8em; }
.permission-guide { background: #fff3cd; color: #856404; padding: 15px; border-radius: 10px; margin-bottom: 20px; font-size: 14px; display: none; }
.controls { margin-bottom: 30px; }
button { background: #4CAF50; color: white; border: none; padding: 15px 30px; margin: 10px; border-radius: 25px; font-size: 16px; cursor: pointer; transition: all 0.3s; min-width: 120px; font-weight: bold; }
button:hover { transform: translateY(-2px); }
button:disabled { background: #cccccc; cursor: not-allowed; transform: none; }
.permission-btn { background: #2196F3; }
#stopButton { background: #f44336; }
.mic-selection { margin-bottom: 20px; padding: 15px; background: #f0f8ff; border-radius: 10px; display: none; }
.mic-selection label { display: block; margin-bottom: 10px; font-weight: bold; color: #333; font-size: 1.1em; }
#micSelect { width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #ddd; font-size: 14px; background: white; cursor: pointer; }
#micSelect:focus { border-color: #2196F3; outline: none; }
.volume-control { margin-bottom: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
.volume-control label { display: block; margin-bottom: 15px; font-weight: bold; color: #333; font-size: 1.1em; }
#volumeSlider { width: 100%; height: 8px; background: #ddd; outline: none; border-radius: 5px; margin-bottom: 15px; }
#volumeSlider::-webkit-slider-thumb { appearance: none; width: 25px; height: 25px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
#volumeDisplay { font-size: 1.5em; font-weight: bold; color: #4CAF50; }
.amplification-info { font-size: 0.9em; color: #666; margin-top: 5px; }
.safety-indicator { display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 10px; }
.noise-filter-control { margin-bottom: 20px; padding: 15px; background: #fff8dc; border-radius: 10px; }
.noise-filter-control h4 { margin-bottom: 10px; color: #333; font-size: 1.1em; }
.filter-option { margin-bottom: 10px; }
.filter-option label { font-size: 0.9em; color: #555; }
.noise-stats { font-size: 0.8em; color: #666; margin-top: 10px; }
#status { padding: 15px; border-radius: 8px; font-weight: bold; background: #e8f5e8; color: #2e7d2e; margin-top: 20px; font-size: 1.1em; }
.device-quality { font-size: 12px; color: #666; margin-top: 5px; }
.advanced-mode { margin-bottom: 20px; padding: 15px; background: #f5f5dc; border-radius: 10px; }
.advanced-mode h4 { margin-bottom: 10px; color: #333; font-size: 1.1em; }
.advanced-controls { margin-top: 15px; display: none; }
.compressor-control { margin-bottom: 10px; }
.compressor-control label { display: block; font-size: 0.9em; color: #555; margin-bottom: 5px; }
.compressor-control input[type="range"] { width: 100%; height: 6px; background: #ddd; outline: none; border-radius: 3px; margin-bottom: 5px; }
.compressor-control input[type="range"]::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
.compressor-display { font-size: 0.85em; color: #666; margin-bottom: 10px; }
.ai-status { font-size: 0.8em; color: #666; margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 5px; display: block !important; }
@media (max-width: 480px) { body { padding: 10px; } .container { padding: 20px; } h1 { font-size: 1.5em; } button { padding: 12px 20px; font-size: 14px; margin: 5px; } }
</style>
</head>
<body>
  <div class="container">
    <h1>🔊 보청기 웹앱 Phase 2.0</h1>
    
    <div id="permissionGuide" class="permission-guide">
      <strong>📱 마이크 권한 허용 방법:</strong><br>
      1. 주소창 좌측 🔒 아이콘 클릭<br>
      2. "마이크" → "허용" 선택<br>
      3. 페이지 새로고침 후 다시 시도
    </div>
    
    <div class="controls">
      <button id="permissionBtn" class="permission-btn">🎤 마이크 권한 요청</button>
      <button id="startButton">시작</button>
      <button id="stopButton">정지</button>
    </div>
    
    <div class="mic-selection">
      <label for="micSelect">🎤 마이크 선택:</label>
      <select id="micSelect">
        <option value="">기본 마이크</option>
      </select>
      <div id="micQuality" class="device-quality"></div>
    </div>
    
    <div class="volume-control">
      <label for="volumeSlider">🔊 볼륨 (안전 증폭):</label>
      <input type="range" id="volumeSlider" min="0" max="100" value="50">
      <div>
        <span id="volumeDisplay">50</span>% 
        <span id="amplificationLevel" class="amplification-info">(1.5배 증폭)</span>
        <span id="safetyIndicator" class="safety-indicator" style="background-color: green;"></span>
      </div>
    </div>
    
    <div class="noise-filter-control" id="noiseFilterControl">
      <h4>🔇 노이즈 필터</h4>
      <div class="filter-option">
        <label><input type="checkbox" id="powerNoiseFilter" checked> 전원 노이즈 제거 (60Hz)</label>
      </div>
      <div class="filter-option">
        <label><input type="checkbox" id="highFreqFilter" checked> 고주파 잡음 제거 (4kHz+)</label>
      </div>
      <div class="noise-stats">
        <div>현재 노이즈: <span id="noiseLevel">-∞ dB</span></div>
        <div>필터 효과: <span id="filterEffectiveness">0% 감소</span></div>
      </div>
    </div>
    
    <div class="advanced-mode" id="advancedModeControl">
      <h4>🚀 고급 모드</h4>
      <div class="filter-option">
        <label><input type="checkbox" id="advancedModeCheckbox"> 고급 모드 활성화</label>
      </div>
      <div class="advanced-controls" id="advancedControls">
        <div class="compressor-control">
          <label for="thresholdSlider">📊 Threshold:</label>
          <input type="range" id="thresholdSlider" min="-30" max="-10" value="-20" step="1">
          <div class="compressor-display">값: <span id="thresholdDisplay">-20dB</span></div>
        </div>
        <div class="compressor-control">
          <label for="ratioSlider">⚖️ Ratio:</label>
          <input type="range" id="ratioSlider" min="2" max="12" value="4" step="1">
          <div class="compressor-display">값: <span id="ratioDisplay">4:1</span></div>
        </div>
        <div class="compressor-control">
          <label for="attackSlider">⚡ Attack:</label>
          <input type="range" id="attackSlider" min="0.001" max="0.1" value="0.01" step="0.001">
          <div class="compressor-display">값: <span id="attackDisplay">0.01s</span></div>
        </div>
        <div class="compressor-control">
          <label for="releaseSlider">⏰ Release:</label>
          <input type="range" id="releaseSlider" min="0.01" max="1.0" value="0.1" step="0.01">
          <div class="compressor-display">값: <span id="releaseDisplay">0.1s</span></div>
        </div>
        <div class="compressor-control">
          <label>
            <input type="checkbox" id="autoQCheckbox" checked> 🤖 자동 Q값 제어
          </label>
        </div>
        <div class="compressor-control" id="manualQMinControl" style="display:none;">
          <label for="minQSlider">🔹 최소 Q값 (조용한 환경):</label>
          <input type="range" id="minQSlider" min="1" max="50" value="5" step="0.5">
          <div class="compressor-display">값: <span id="minQDisplay">5</span></div>
        </div>
        <div class="compressor-control" id="manualQMaxControl" style="display:none;">
          <label for="maxQSlider">🔸 최대 Q값 (시끄러운 환경):</label>
          <input type="range" id="maxQSlider" min="1" max="100" value="50" step="1">
          <div class="compressor-display">값: <span id="maxQDisplay">50</span></div>
        </div>
        <div class="ai-status" style="display: block !important;">
          <div>🎚️ 압축량: <span id="compressionAmount">0%</span></div>
          <div>🌍 환경: <span id="environmentType">측정 중</span></div>
          <div>🧠 적응적 필터 강도: <span id="adaptiveStrength">0%</span></div>
        </div>
      </div>
    </div>

    <div id="status">🎤 마이크 권한을 요청해주세요</div>
  </div>

<script>
const permissionBtn = document.getElementById('permissionBtn');
const startButton = document.getElementById('startButton');
const stopButton = document.getElementById('stopButton');
const volumeSlider = document.getElementById('volumeSlider');
const volumeDisplay = document.getElementById('volumeDisplay');
const statusDiv = document.getElementById('status');
const permissionGuide = document.getElementById('permissionGuide');
const micSelect = document.getElementById('micSelect');
const micQuality = document.getElementById('micQuality');

// Phase 2.0: 고급모드 컨트롤 요소들
const advancedModeCheckbox = document.getElementById('advancedModeCheckbox');
const advancedControls = document.getElementById('advancedControls');
const thresholdSlider = document.getElementById('thresholdSlider');
const ratioSlider = document.getElementById('ratioSlider');
const attackSlider = document.getElementById('attackSlider');
const releaseSlider = document.getElementById('releaseSlider');
const thresholdDisplay = document.getElementById('thresholdDisplay');
const ratioDisplay = document.getElementById('ratioDisplay');
const attackDisplay = document.getElementById('attackDisplay');
const releaseDisplay = document.getElementById('releaseDisplay');
const compressionAmount = document.getElementById('compressionAmount');
const environmentType = document.getElementById('environmentType');
const adaptiveStrength = document.getElementById('adaptiveStrength');

// 자동/수동 Q값 제어 요소들 (새로 추가)
const autoQCheckbox = document.getElementById('autoQCheckbox');
const minQSlider = document.getElementById('minQSlider');
const maxQSlider = document.getElementById('maxQSlider');
const minQDisplay = document.getElementById('minQDisplay');
const maxQDisplay = document.getElementById('maxQDisplay');
const manualQMinControl = document.getElementById('manualQMinControl');
const manualQMaxControl = document.getElementById('manualQMaxControl');

let audioContext, microphoneStream, gainNode, highpassFilter, source, isRunning = false;
let notchFilter60Hz, lowpassFilter4kHz, analyserNode; // Phase 1.9 추가 필터들
let compressorNode, analyserEnv, adaptiveFilterStrength = 0; // Phase 2.0 고급모드 변수들
let hasPermission = false;
let wakeLock = null;
let wasRunningBeforeHidden = false;
let selectedMicrophoneId = null;
let failoverAttempts = 0;
const MAX_FAILOVER_ATTEMPTS = 3;

// 자동/수동 Q값 제어 변수들 (새로 추가)
let minQValue = 5;
let maxQValue = 50;
let autoQEnabled = true;

// 초기 상태 설정
startButton.disabled = true;
stopButton.disabled = true;

// Phase 2.0: 고급모드 초기 설정 - 토글은 보이고 컨트롤만 숨김
advancedControls.style.display = 'none';

// Phase 1.7: 실시간 장치 감지 및 안정성 강화

// 마이크 품질 검증 함수
async function validateAudioStream(stream) {
  try {
    const tracks = stream.getAudioTracks();
    if (tracks.length === 0) {
      throw new Error('오디오 트랙이 없습니다');
    }
    
    const track = tracks[0];
    const settings = track.getSettings();
    
    // 트랙 상태 확인
    if (track.readyState !== 'live') {
      throw new Error(`트랙 상태 이상: ${track.readyState}`);
    }
    
    // 품질 정보 표시
    const sampleRate = settings.sampleRate || 'N/A';
    const channelCount = settings.channelCount || 'N/A';
    
    micQuality.innerHTML = `
      📊 품질: ${sampleRate}Hz, ${channelCount}채널
      <br>📶 상태: ${track.enabled ? '활성' : '비활성'}
    `;
    
    console.log('마이크 품질 검증 완료:', settings);
    return true;
    
  } catch (err) {
    console.error('마이크 품질 검증 실패:', err);
    micQuality.textContent = '❌ 품질 검증 실패';
    return false;
  }
}

// 스마트 복구 시스템
async function attemptSmartRecovery(originalDeviceId) {
  const fallbackOptions = [
    { id: null, name: '기본 마이크' },
    { id: 'first-available', name: '첫번째 가용 마이크' }
  ];
  
  for (const option of fallbackOptions) {
    try {
      console.log(`복구 시도 ${failoverAttempts + 1}/${MAX_FAILOVER_ATTEMPTS}: ${option.name}`);
      
      let deviceId = option.id;
      if (deviceId === 'first-available') {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        deviceId = audioInputs.length > 0 ? audioInputs[0].deviceId : null;
      }
      
      await switchMicrophone(deviceId, true); // skipFailover = true
      failoverAttempts = 0; // 성공 시 초기화
      return true;
      
    } catch (err) {
      console.error(`복구 실패 (${option.name}):`, err);
      continue;
    }
  }
  
  failoverAttempts = 0;
  statusDiv.textContent = '❌ 모든 복구 시도 실패 - 권한 재요청 필요';
  statusDiv.style.background = '#f8d7da';
  statusDiv.style.color = '#721c24';
  
  // 권한 버튼 다시 활성화
  permissionBtn.disabled = false;
  startButton.disabled = true;
  
  return false;
}

// 마이크 목록 업데이트 함수 (개선됨)
async function updateMicrophoneList() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(device => device.kind === 'audioinput');
    
    // 기존 옵션 제거 (기본 옵션 제외)
    while (micSelect.children.length > 1) {
      micSelect.removeChild(micSelect.lastChild);
    }
    
    if (audioInputs.length === 0) {
      console.warn('사용 가능한 마이크가 없습니다');
      return;
    }
    
    let wirelessDeviceDetected = false;
    
    audioInputs.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      
      // 기기 타입 자동 인식 및 아이콘 추가
      let deviceName = device.label || `마이크 ${index + 1}`;
      let icon = '🎤';
      
      const lowerName = deviceName.toLowerCase();
      
      // 무선 장치 감지
      if (lowerName.includes('bluetooth') || lowerName.includes('wireless') || 
          lowerName.includes('airpods') || lowerName.includes('buds') || 
          lowerName.includes('headset')) {
        wirelessDeviceDetected = true;
        icon = '📡';
        deviceName = `무선 마이크: ${deviceName}`;
      } else if (lowerName.includes('built-in') || lowerName.includes('internal') || lowerName.includes('default')) {
        icon = '📱';
        deviceName = `내장 마이크: ${deviceName}`;
      } else if (lowerName.includes('headphone') || lowerName.includes('earphone')) {
        icon = '🎧';
        deviceName = `이어폰 마이크: ${deviceName}`;
      } else if (lowerName.includes('usb') || lowerName.includes('external') || lowerName.includes('webcam')) {
        icon = '🖥️';
        deviceName = `외장 마이크: ${deviceName}`;
      }
      
      option.text = `${icon} ${deviceName}`;
      micSelect.appendChild(option);
    });
    
    // 무선 장치 경고
    if (wirelessDeviceDetected && !isRunning) {
      statusDiv.textContent = '⚠️ 무선이어폰 감지: 지연시간(160ms+) 발생 가능. 유선 이어폰 권장';
      statusDiv.style.background = '#fff3cd';
      statusDiv.style.color = '#856404';
    }
    
    console.log(`발견된 마이크 ${audioInputs.length}개 (무선: ${wirelessDeviceDetected ? 'O' : 'X'})`);
    document.querySelector('.mic-selection').style.display = 'block';
    
  } catch (err) {
    console.error('마이크 목록 업데이트 실패:', err);
    statusDiv.textContent = '⚠️ 마이크 목록을 가져올 수 없습니다';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
  }
}

// 실시간 마이크 전환 함수 (개선됨)
async function switchMicrophone(deviceId, skipFailover = false) {
  if (!isRunning) return;
  
  try {
    console.log('마이크 전환 시작:', deviceId);
    statusDiv.textContent = '🔄 마이크 전환 중...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    // 현재 마이크 스트림 정지
    if (microphoneStream) {
      microphoneStream.getTracks().forEach(track => track.stop());
    }
    
    // 새 마이크로 스트림 생성
    const constraints = {
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    };
    
    if (deviceId) {
      constraints.audio.deviceId = { exact: deviceId };
    }
    
    microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    // 마이크 품질 검증
    const isValid = await validateAudioStream(microphoneStream);
    if (!isValid) {
      throw new Error('마이크 품질 검증 실패');
    }
    
    // 기존 오디오 노드 연결 해제
    if (source) {
      source.disconnect();
    }
    
    // Phase 2.0: 새 소스로 다시 연결 (고급모드 고려)
    source = audioContext.createMediaStreamSource(microphoneStream);
    connectAudioChain();
    
    console.log('마이크 전환 완료');
    statusDiv.textContent = '🔊 보청기 작동 중 (이어폰 착용 권장)';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    failoverAttempts = 0; // 성공 시 초기화
    
  } catch (err) {
    console.error('마이크 전환 실패:', err);
    statusDiv.textContent = `❌ 마이크 전환 실패: ${err.message}`;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
      failoverAttempts++;
      
      if (!skipFailover && failoverAttempts <= MAX_FAILOVER_ATTEMPTS) {
      statusDiv.textContent = `❌ 마이크 전환 실패 (${failoverAttempts}/${MAX_FAILOVER_ATTEMPTS}) - 복구 중...`;
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.color = '#721c24';
      
      // 스마트 복구 시도
      setTimeout(() => attemptSmartRecovery(deviceId), 1000);
    } else {
      statusDiv.textContent = '❌ 마이크 전환 최종 실패';
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.color = '#721c24';
      
      if (!skipFailover) {
        await attemptSmartRecovery(deviceId);
      }
    }
  }
}

// 실시간 장치 변경 감지 이벤트 리스너
navigator.mediaDevices.addEventListener('devicechange', () => {
  console.log('장치 변경 감지 - 마이크 목록 업데이트');
  setTimeout(updateMicrophoneList, 500); // 500ms 지연으로 안정성 확보
});

// 1단계: 마이크 권한 요청
permissionBtn.addEventListener('click', async () => {
  try {
    statusDiv.textContent = '🔄 마이크 권한 확인 중...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    
    // 권한 성공 - 임시 스트림 종료
    stream.getTracks().forEach(track => track.stop());
    hasPermission = true;
    
    statusDiv.textContent = '✅ 마이크 권한 허용됨 - 마이크를 선택하고 시작하세요';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    permissionBtn.disabled = true;
    startButton.disabled = false;
    permissionGuide.style.display = 'none';
    
    // 마이크 목록 업데이트
    await updateMicrophoneList();
    
  } catch (err) {
    let errorMessage = '❌ 마이크 접근 실패: ';
    if (err.name === 'NotAllowedError') {
      errorMessage += '마이크 권한을 허용해주세요.';
    } else if (err.name === 'NotFoundError') {
      errorMessage += '마이크 장치가 발견되지 않았습니다.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += '지원되지 않는 마이크 설정입니다.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('권한 오류:', err);
  }
});

// 2단계: 보청기 시작 (마이크 선택 지원)
startButton.addEventListener('click', async () => {
  try {
    statusDiv.textContent = '🚀 보청기 시작 중...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    // 선택된 마이크 설정
    const constraints = {
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    };
    
    if (selectedMicrophoneId) {
      constraints.audio.deviceId = { exact: selectedMicrophoneId };
    }
    
    microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    // 마이크 품질 검증
    const isValid = await validateAudioStream(microphoneStream);
    if (!isValid) {
      throw new Error('마이크 품질 검증 실패');
    }
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    console.log("AudioContext initial state:", audioContext.state); 
    if (audioContext.state === 'suspended') {
        console.log("Attempting to resume AudioContext...");
        await audioContext.resume();
        console.log("AudioContext state after resume:", audioContext.state); 
    }

    source = audioContext.createMediaStreamSource(microphoneStream);
    gainNode = audioContext.createGain();
    highpassFilter = audioContext.createBiquadFilter();
    highpassFilter.type = 'highpass';
    highpassFilter.frequency.setValueAtTime(100, audioContext.currentTime); 

    const volume = volumeSlider.value / 100;
    gainNode.gain.value = volume * 3; // Phase 1.9: 3배 안전 증폭
    
    // 실시간 증폭 레벨 표시 업데이트
    updateAmplificationDisplay(volume * 3);

    // Phase 1.9: 노이즈 필터 추가
    notchFilter60Hz = audioContext.createBiquadFilter();
    notchFilter60Hz.type = 'notch';
    notchFilter60Hz.frequency.setValueAtTime(60, audioContext.currentTime);
    notchFilter60Hz.Q.setValueAtTime(10, audioContext.currentTime);
    
    lowpassFilter4kHz = audioContext.createBiquadFilter();
    lowpassFilter4kHz.type = 'lowpass';
    lowpassFilter4kHz.frequency.setValueAtTime(4000, audioContext.currentTime);
    
    analyserNode = audioContext.createAnalyser();
    analyserNode.fftSize = 256;
    
    // Phase 2.0: 오디오 체인 연결 (고급모드 고려)
    connectAudioChain();
    
    // 노이즈 레벨 모니터링 시작
    startNoiseMonitoring();
    
    // Phase 2.0: 고급모드 설정 적용
    if (advancedModeCheckbox.checked) {
      await setupAdvancedMode();
    }
    
    startButton.disabled = true;
    stopButton.disabled = false;
    isRunning = true;
    
    statusDiv.textContent = '🔊 보청기 작동 중 (이어폰 착용 권장)';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    // Wake Lock API 사용 (지원하는 브라우저에서)
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock acquired');
      } catch (err) {
        console.error('Wake Lock request failed:', err);
      }
    }

  } catch (err) {
    let errorMessage = '❌ 보청기 시작 실패: ';
    if (err.name === 'NotAllowedError') {
        errorMessage += '마이크 권한을 허용해주세요.';
    } else if (err.name === 'NotFoundError'){
        errorMessage += 'AudioContext가 지원되지 않습니다.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += '지원되지 않는 마이크 설정입니다.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('보청기 시작 오류:', err);
  }
});

// 3단계: 보청기 정지 (수정됨 - suspend 사용)
stopButton.addEventListener('click', async () => {
  // 마이크 스트림 정리
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
    microphoneStream = null;
  }
  
  // 오디오 노드들 명시적 해제
  if (source) {
    source.disconnect();
    source = null;
  }
  if (gainNode) {
    gainNode.disconnect();
    gainNode = null;
  }
  if (highpassFilter) {
    highpassFilter.disconnect();
    highpassFilter = null;
  }
  if (notchFilter60Hz) {
    notchFilter60Hz.disconnect();
    notchFilter60Hz = null;
  }
  if (lowpassFilter4kHz) {
    lowpassFilter4kHz.disconnect();
    lowpassFilter4kHz = null;
  }
  if (analyserNode) {
    analyserNode.disconnect();
    analyserNode = null;
  }
  
  // AudioContext suspend (재사용 가능하도록)
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
      console.log('AudioContext suspended (reusable)');
    } catch (err) {
      console.error('AudioContext suspend failed:', err);
    }
  }
  
  // Wake Lock 해제
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock released');
  }
  
  // 품질 정보 초기화
  micQuality.textContent = '';
  
  startButton.disabled = false;
  stopButton.disabled = true;
  isRunning = false;
  
  statusDiv.textContent = '⏹️ 보청기 정지됨 (재시작 가능)';
  statusDiv.style.background = '#f8d7da';
  statusDiv.style.color = '#721c24';
});

// 마이크 선택 변경 이벤트
micSelect.addEventListener('change', async function() {
  selectedMicrophoneId = this.value || null;
  console.log('마이크 선택 변경:', selectedMicrophoneId);
  
  if (isRunning) {
    await switchMicrophone(selectedMicrophoneId);
  }
});

// Phase 1.9: 볼륨 조절 개선
volumeSlider.addEventListener('input', function() {
  const volume = this.value / 100;
  volumeDisplay.textContent = this.value;
  
  if (gainNode && isRunning) {
    gainNode.gain.value = volume * 3; // 3배 증폭
    updateAmplificationDisplay(volume * 3);
    updateSafetyIndicator(volume * 3);
  }
});

// Phase 1.9: 노이즈 필터 제어
document.getElementById('powerNoiseFilter').addEventListener('change', function() {
  if (notchFilter60Hz) {
    // 체크 상태에 따른 필터 활성화/비활성화
    if (this.checked) {
      notchFilter60Hz.frequency.setValueAtTime(60, audioContext.currentTime);
    } else {
      notchFilter60Hz.frequency.setValueAtTime(22050, audioContext.currentTime); // 비활성화
    }
    updateFilterEffectiveness();
  }
});

// Phase 2.0: 고급모드 토글 이벤트 리스너 (수정됨 - 체인 재연결 로직 강화)
advancedModeCheckbox.addEventListener('change', function() {
  console.log(`🔧 Advanced mode toggled: ${this.checked ? 'ON' : 'OFF'}`);
  
  if (this.checked) {
    // 고급모드 활성화
    advancedControls.style.display = 'block';
    if (isRunning && audioContext) {
      console.log('🚀 Setting up advanced mode...');
      setupAdvancedMode().then(() => {
        console.log('✅ Advanced mode setup complete');
      }).catch(err => {
        console.error('❌ Advanced mode setup failed:', err);
      });
    }
  } else {
    // 고급모드 비활성화
    advancedControls.style.display = 'none';
    console.log('📡 Switching to basic mode...');
    
    // 고급모드 전용 노드들 정리
    try {
      if (compressorNode) {
        compressorNode.disconnect();
        compressorNode = null;
        console.log('🗑️ Compressor node cleaned up');
      }
      if (analyserEnv) {
        analyserEnv.disconnect();
        analyserEnv = null;
        console.log('🗑️ Environment analyser cleaned up');
      }
    } catch (err) {
      console.warn('⚠️ Cleanup warning:', err.message);
    }
    
    // 기본모드로 체인 재연결
    if (isRunning && source) {
      const reconnected = connectAudioChain();
      if (reconnected) {
        console.log('✅ Switched to basic mode successfully');
      } else {
        console.error('❌ Failed to reconnect in basic mode');
      }
    }
  }
});

// Phase 2.0: 컴프레서 슬라이더 이벤트 리스너
thresholdSlider.addEventListener('input', updateCompressorSettings);
ratioSlider.addEventListener('input', updateCompressorSettings);
attackSlider.addEventListener('input', updateCompressorSettings);
releaseSlider.addEventListener('input', updateCompressorSettings);

// 자동/수동 Q값 제어 이벤트 리스너 (새로 추가)
autoQCheckbox.addEventListener('change', function() {
  autoQEnabled = this.checked;
  const displayStyle = autoQEnabled ? 'none' : 'block';
  manualQMinControl.style.display = displayStyle;
  manualQMaxControl.style.display = displayStyle;
  
  console.log('🔄 Q값 제어 모드 변경:', autoQEnabled ? '자동' : '수동');
  
  // 수동 모드로 전환 시 즉시 Q값 적용
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
    console.log('수동 모드로 전환 - 즉시 Q값 적용');
  }
});

minQSlider.addEventListener('input', function() {
  minQValue = parseFloat(this.value);
  minQDisplay.textContent = minQValue;
  // 최소값이 최대값보다 크면 최대값 조정
  if (minQValue >= maxQValue) {
    maxQValue = minQValue + 1;
    maxQSlider.value = maxQValue;
    maxQDisplay.textContent = maxQValue;
  }
  
  // 수동 모드에서 실시간 Q값 적용
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
  }
  
  console.log(`최소 Q값 변경: ${minQValue} (자동모드: ${autoQEnabled})`);
});

maxQSlider.addEventListener('input', function() {
  maxQValue = parseFloat(this.value);
  maxQDisplay.textContent = maxQValue;
  // 최대값이 최소값보다 작으면 최소값 조정
  if (maxQValue <= minQValue) {
    minQValue = maxQValue - 1;
    minQSlider.value = minQValue;
    minQDisplay.textContent = minQValue;
  }
  
  // 수동 모드에서 실시간 Q값 적용
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
  }
  
  console.log(`최대 Q값 변경: ${maxQValue} (자동모드: ${autoQEnabled})`);
});

// 수동 모드 Q값 실시간 적용 함수 (새로 추가)
function applyManualQValue() {
  if (!notchFilter60Hz || !document.getElementById('powerNoiseFilter').checked) {
    console.log('수동 Q값 적용 시폐: 필터 비활성화');
    return;
  }
  
  // 수동 모드에서는 최소 Q값 사용 (사용자가 직접 제어)
  const qValue = Math.min(Math.max(minQValue, 1), 100);
  
  try {
    notchFilter60Hz.Q.linearRampToValueAtTime(qValue, audioContext.currentTime + 0.1);
    console.log(`🔧 수동 Q값 적용: ${qValue} (범위: ${minQValue}-${maxQValue})`);
    
    // 디스플레이 업데이트
    if (adaptiveStrength) {
      adaptiveStrength.textContent = `Q: ${minQValue}-${maxQValue}`;
    }
  } catch (err) {
    console.error('수동 Q값 적용 실패:', err);
  }
}

// Phase 2.0: 고급모드 설정 함수 (수정됨 - 에러 처리 강화)
async function setupAdvancedMode() {
  try {
    if (!audioContext) {
      console.error('❌ AudioContext not available for advanced mode');
      return false;
    }
    
    if (audioContext.state !== 'running') {
      console.warn('⚠️ AudioContext not running, attempting to resume...');
      await audioContext.resume();
    }
    
    console.log('🏗️ Creating advanced mode nodes...');
    
    // 컴프레서 노드 생성
    compressorNode = audioContext.createDynamicsCompressor();
    analyserEnv = audioContext.createAnalyser();
    analyserEnv.fftSize = 256;
    
    console.log('🎛️ Advanced nodes created successfully');
    
    // 초기 컴프레서 설정
    updateCompressorSettings();
    
    // 오디오 체인 재연결
    const chainConnected = connectAudioChain();
    if (!chainConnected) {
      throw new Error('Failed to connect advanced audio chain');
    }
    
    // 모니터링 시작
    if (isRunning) {
      startAdvancedMonitoring();
      console.log('📊 Advanced monitoring started');
    }
    
    return true;
    
  } catch (err) {
    console.error('❌ Advanced mode setup failed:', err);
    
    // 실패 시 정리
    if (compressorNode) {
      compressorNode.disconnect();
      compressorNode = null;
    }
    if (analyserEnv) {
      analyserEnv.disconnect();
      analyserEnv = null;
    }
    
    return false;
  }
}

// Phase 2.0: 컴프레서 설정 업데이트 (수정됨 - linearRampToValueAtTime 사용)
function updateCompressorSettings() {
  // compressorNode 존재 및 연결 상태 확인
  if (!compressorNode) {
    console.warn('⚠️ Compressor node not initialized. Advanced Mode may be disabled.');
    return;
  }
  
  if (!audioContext || audioContext.state !== 'running') {
    console.warn('⚠️ AudioContext not running. Current state:', audioContext ? audioContext.state : 'null');
    return;
  }
  
  const threshold = parseFloat(thresholdSlider.value);
  const ratio = parseFloat(ratioSlider.value);
  const attack = parseFloat(attackSlider.value);
  const release = parseFloat(releaseSlider.value);
  
  // linearRampToValueAtTime 사용으로 부드러운 전환 (0.1초)
  const currentTime = audioContext.currentTime;
  const rampTime = 0.1;
  
  try {
    compressorNode.threshold.linearRampToValueAtTime(threshold, currentTime + rampTime);
    compressorNode.ratio.linearRampToValueAtTime(ratio, currentTime + rampTime);
    compressorNode.attack.linearRampToValueAtTime(attack, currentTime + rampTime);
    compressorNode.release.linearRampToValueAtTime(release, currentTime + rampTime);
    
    console.log(`🎛️ Compressor settings updated: T:${threshold}dB, R:${ratio}:1, A:${attack}s, Rel:${release}s`);
  } catch (err) {
    console.error('❌ Failed to update compressor settings:', err);
  }
  
  // 디스플레이 업데이트
  thresholdDisplay.textContent = `${threshold}dB`;
  ratioDisplay.textContent = `${ratio}:1`;
  attackDisplay.textContent = `${attack}s`;
  releaseDisplay.textContent = `${release}s`;
}

// Phase 2.0: 오디오 체인 연결 함수 (수정됨 - 연결 상태 확인 로직 추가)
function connectAudioChain() {
  console.log('🔗 Connecting audio chain...');
  
  // 필수 노드들 존재 확인
  if (!source) {
    console.error('❌ Source node not ready');
    return false;
  }
  if (!notchFilter60Hz || !lowpassFilter4kHz || !highpassFilter || !gainNode || !analyserNode) {
    console.error('❌ Required audio nodes not initialized');
    return false;
  }
  
  // 기존 연결 해제
  try {
    source.disconnect();
    if (compressorNode) compressorNode.disconnect();
    if (analyserEnv) analyserEnv.disconnect();
    notchFilter60Hz.disconnect();
    lowpassFilter4kHz.disconnect();
    highpassFilter.disconnect();
    gainNode.disconnect();
    analyserNode.disconnect();
    console.log('🔄 Previous connections disconnected');
  } catch (err) {
    console.warn('⚠️ Some disconnections failed (normal on first run):', err.message);
  }
  
  try {
    // 새 체인 연결 - 고급모드 확인
    if (advancedModeCheckbox.checked && compressorNode && analyserEnv) {
      // 고급모드: source -> analyserEnv -> compressor -> notch -> lowpass -> highpass -> gain -> analyser -> destination
      source.connect(analyserEnv);
      analyserEnv.connect(compressorNode);
      compressorNode.connect(notchFilter60Hz);
      console.log('🚀 Advanced mode chain: source -> analyserEnv -> compressor -> filters -> gain -> output');
    } else {
      // 기본모드: source -> notch -> lowpass -> highpass -> gain -> analyser -> destination
      source.connect(notchFilter60Hz);
      console.log('📡 Basic mode chain: source -> filters -> gain -> output');
    }
    
    // 공통 필터 체인 연결
    notchFilter60Hz.connect(lowpassFilter4kHz);
    lowpassFilter4kHz.connect(highpassFilter);
    highpassFilter.connect(gainNode);
    gainNode.connect(analyserNode);
    analyserNode.connect(audioContext.destination);
    
    console.log('✅ Audio chain connected successfully');
    return true;
  } catch (err) {
    console.error('❌ Failed to connect audio chain:', err);
    return false;
  }
}

// Phase 2.0: 고급모드 모니터링 시작
function startAdvancedMonitoring() {
  if (!analyserEnv || !advancedModeCheckbox.checked) return;
  
  const bufferLength = analyserEnv.frequencyBinCount;
  const dataArray = new Float32Array(bufferLength); // Float 배열로 변경
  const timeDataArray = new Float32Array(bufferLength);
  
  function updateAdvancedStats() {
    if (!isRunning || !analyserEnv || !advancedModeCheckbox.checked) return;
    
    console.log('🔍 고급모드 모니터링 작동 중... 자동모드:', autoQEnabled);
    
    // 환경 분석 - 올바른 TimeDomain RMS 노이즈 측정
    analyserEnv.getFloatTimeDomainData(timeDataArray);
    let rms = 0;
    for (let i = 0; i < timeDataArray.length; i++) {
      rms += timeDataArray[i] * timeDataArray[i];
    }
    rms = Math.sqrt(rms / timeDataArray.length);
    
    // dB 변환 (올바른 공식)
    const noiseLevel = Math.round(20 * Math.log10(rms + 1e-10));
    
    console.log(`🔊 실시간 측정 - RMS: ${rms.toFixed(4)}, 노이즈 레벨: ${noiseLevel}dB`);
    
    // 환경 분류 및 적응적 필터 강도 설정 (수동 모드 고려)
    let environment = '측정 중';
    
    if (autoQEnabled) {
      // 자동 모드: 현실적인 환경 분류 기준
      if (noiseLevel <= -60) {
        environment = '🏠 조용함';
        adaptiveFilterStrength = 20;
      } else if (noiseLevel <= -40) {
        environment = '🏢 보통';
        adaptiveFilterStrength = 50;
      } else {
        environment = '🚗 시끄러움';
        adaptiveFilterStrength = 80;
      }
      console.log(`자동 모드 - 노이즈: ${noiseLevel}dB, 환경: ${environment}, 강도: ${adaptiveFilterStrength}%`);
    } else {
      // 수동 모드: 고정값 사용
      environment = '🔧 수동 제어';
      adaptiveFilterStrength = 0; // 수동 모드에서는 고정
      console.log(`수동 모드 - Q값 범위: ${minQValue}-${maxQValue}`);
    }
    
    // 압축량 계산 (현실적 시뮬레이션)
    let compressionPercent = 0;
    if (compressorNode && advancedModeCheckbox.checked) {
      const threshold = parseFloat(thresholdSlider.value);
      const ratio = parseFloat(ratioSlider.value);
      
      // 입력 신호가 threshold를 넘는 경우에만 압축 발생
      if (noiseLevel > threshold) {
        const excessLevel = noiseLevel - threshold;
        const compressedExcess = excessLevel / ratio;
        const reduction = excessLevel - compressedExcess;
        
        // 압축량을 백분율로 변환 (최대 80%로 제한)
        compressionPercent = Math.min(Math.round((reduction / Math.abs(excessLevel)) * 100), 80);
      }
      
      console.log(`🎛️ 압축 계산 - Threshold: ${threshold}dB, Input: ${noiseLevel}dB, 압축량: ${compressionPercent}%`);
    }
    
    // 디스플레이 업데이트 (모드별 처리)
    environmentType.textContent = environment;
    
    if (autoQEnabled) {
      adaptiveStrength.textContent = `${adaptiveFilterStrength}%`;
    } else {
      // 수동 모드: Q값 범위 표시
      adaptiveStrength.textContent = `Q: ${minQValue}-${maxQValue}`;
    }
    
    compressionAmount.textContent = `${compressionPercent}%`;
    console.log(`📊 디스플레이 업데이트 - 환경: ${environment}, 압축: ${compressionPercent}%`);
    
    // 적응적 필터 적용 (자동/수동 Q값 제어) - 개선된 로직
    if (notchFilter60Hz && document.getElementById('powerNoiseFilter').checked) {
      let qValue;
      
      if (autoQEnabled) {
        // 자동 모드: 환경에 따라 사용자 설정 범위 내에서 동적 조절
        const qRange = maxQValue - minQValue;
        qValue = minQValue + (adaptiveFilterStrength / 100) * qRange;
        console.log(`자동 Q값: ${qValue.toFixed(1)} (환경: ${adaptiveFilterStrength}%)`);
      } else {
        // 수동 모드: 최소값 고정 사용 (사용자가 직접 제어)
        qValue = minQValue;
        console.log(`수동 Q값: ${qValue} (고정)`);
      }
      
      // 안전 범위 제한 (1-100)
      qValue = Math.min(Math.max(qValue, 1), 100);
      notchFilter60Hz.Q.linearRampToValueAtTime(qValue, audioContext.currentTime + 0.1);
    }
    
    requestAnimationFrame(updateAdvancedStats);
  }
  
  updateAdvancedStats();
}

document.getElementById('highFreqFilter').addEventListener('change', function() {
  if (lowpassFilter4kHz) {
    if (this.checked) {
      lowpassFilter4kHz.frequency.setValueAtTime(4000, audioContext.currentTime);
    } else {
      lowpassFilter4kHz.frequency.setValueAtTime(22050, audioContext.currentTime); // 비활성화
    }
    updateFilterEffectiveness();
  }
});

// Phase 1.9: 새로운 함수들
function updateAmplificationDisplay(gainValue) {
  const amplificationLevel = document.getElementById('amplificationLevel');
  amplificationLevel.textContent = `(${gainValue.toFixed(1)}배 증폭)`;
}

function updateSafetyIndicator(gainValue) {
  const safetyIndicator = document.getElementById('safetyIndicator');
  if (gainValue >= 2.5) {
    safetyIndicator.style.backgroundColor = 'red';
  } else if (gainValue >= 2.0) {
    safetyIndicator.style.backgroundColor = 'orange';
  } else {
    safetyIndicator.style.backgroundColor = 'green';
  }
}

function startNoiseMonitoring() {
  const bufferLength = analyserNode.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  function updateNoiseLevel() {
    if (!isRunning || !analyserNode) return;
    
    analyserNode.getByteFrequencyData(dataArray);
    
    // 간단한 노이즈 레벨 계산
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      sum += dataArray[i];
    }
    const average = sum / bufferLength;
    const noiseLevel = Math.round(20 * Math.log10(average / 255) + 60); // dB 변환
    
    document.getElementById('noiseLevel').textContent = `${noiseLevel} dB`;
    
    requestAnimationFrame(updateNoiseLevel);
  }
  
  updateNoiseLevel();
}

function updateFilterEffectiveness() {
  const powerFilterEnabled = document.getElementById('powerNoiseFilter').checked;
  const highFreqFilterEnabled = document.getElementById('highFreqFilter').checked;
  
  let effectiveness = 0;
  if (powerFilterEnabled) effectiveness += 45; // 45% 효과
  if (highFreqFilterEnabled) effectiveness += 35; // 35% 효과
  
  document.getElementById('filterEffectiveness').textContent = `${effectiveness}% 감소`;
}

// Page Visibility API (개선됨)
document.addEventListener('visibilitychange', async () => {
  if (document.hidden && isRunning) {
    // 백그라운드로 전환 시 일시정지
    wasRunningBeforeHidden = true;
    if (audioContext && audioContext.state === 'running') {
      try {
        await audioContext.suspend();
        console.log('AudioContext suspended (background)');
        statusDiv.textContent = '⏸️ 백그라운드 일시정지 중...';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      } catch (err) {
        console.error('Background suspend failed:', err);
      }
    }
  } else if (!document.hidden && wasRunningBeforeHidden && isRunning) {
    // 포그라운드로 복귀 시 재개
    if (audioContext && audioContext.state === 'suspended') {
      try {
        await audioContext.resume();
        console.log('AudioContext resumed (foreground)');
        statusDiv.textContent = '🔊 보청기 작동 중 (이어폰 착용 권장)';
        statusDiv.style.background = '#d4edda';
        statusDiv.style.color = '#155724';
      } catch (err) {
        console.error('Foreground resume failed:', err);
      }
    }
    wasRunningBeforeHidden = false;
  }
});

// 자동 복구 시스템 (개선됨)
async function checkAudioHealth() {
  if (isRunning && audioContext) {
    if (audioContext.state === 'suspended') {
      console.log('AudioContext suspended, attempting resume...');
      try {
        await audioContext.resume();
        console.log('AudioContext resumed successfully');
      } catch (err) {
        console.error('Failed to resume AudioContext:', err);
        statusDiv.textContent = '⚠️ 연결 복구 중... 잠시만 기다려주세요';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      }
    }
  }
}

// 5초마다 상태 체크
setInterval(checkAudioHealth, 5000);

// 페이지 종료 시 정리 (개선됨)
window.addEventListener('beforeunload', async () => {
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
  }
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
    } catch (err) {
      console.error('Beforeunload suspend failed:', err);
    }
  }
  if (wakeLock) {
    wakeLock.release();
  }
});

// 오디오 컨텍스트 자동 재개 (개선됨)
let resumeAudioContext = async () => {
  if (audioContext && audioContext.state === 'suspended') {
    try {
      console.log("AudioContext state before resume:", audioContext.state);
      await audioContext.resume();
      console.log("AudioContext state after resume:", audioContext.state);
    } catch (err) {
      console.error("AudioContext resume failed:", err);
    }
  }
}

document.addEventListener('click', resumeAudioContext);
document.addEventListener('touchstart', resumeAudioContext); // 모바일 지원

// 초기화: 페이지 로드 시 마이크 목록 확인
setTimeout(async () => {
  if (hasPermission) {
    await updateMicrophoneList();
  }
}, 100);
</script>
</body>
</html>