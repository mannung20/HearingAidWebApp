<!DOCTYPE html>
<html>
<head>
<title>ë³´ì²­ê¸° ì›¹ì•±</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; min-height: 100vh; display: flex; align-items: center; justify-content: center; }
.container { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15); max-width: 400px; width: 100%; text-align: center; }
h1 { color: #333; margin-bottom: 30px; font-size: 1.8em; }
.permission-guide { background: #fff3cd; color: #856404; padding: 15px; border-radius: 10px; margin-bottom: 20px; font-size: 14px; display: none; }
.controls { margin-bottom: 30px; }
button { background: #4CAF50; color: white; border: none; padding: 15px 30px; margin: 10px; border-radius: 25px; font-size: 16px; cursor: pointer; transition: all 0.3s; min-width: 120px; font-weight: bold; }
button:hover { transform: translateY(-2px); }
button:disabled { background: #cccccc; cursor: not-allowed; transform: none; }
.permission-btn { background: #2196F3; }
#stopButton { background: #f44336; }
.mic-selection { margin-bottom: 20px; padding: 15px; background: #f0f8ff; border-radius: 10px; display: none; }
.mic-selection label { display: block; margin-bottom: 10px; font-weight: bold; color: #333; font-size: 1.1em; }
#micSelect { width: 100%; padding: 12px; border-radius: 8px; border: 2px solid #ddd; font-size: 14px; background: white; cursor: pointer; }
#micSelect:focus { border-color: #2196F3; outline: none; }
.volume-control { margin-bottom: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px; }
.volume-control label { display: block; margin-bottom: 15px; font-weight: bold; color: #333; font-size: 1.1em; }
#volumeSlider { width: 100%; height: 8px; background: #ddd; outline: none; border-radius: 5px; margin-bottom: 15px; }
#volumeSlider::-webkit-slider-thumb { appearance: none; width: 25px; height: 25px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
#volumeDisplay { font-size: 1.5em; font-weight: bold; color: #4CAF50; }
.amplification-info { font-size: 0.9em; color: #666; margin-top: 5px; }
.safety-indicator { display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 10px; }
.noise-filter-control { margin-bottom: 20px; padding: 15px; background: #fff8dc; border-radius: 10px; }
.noise-filter-control h4 { margin-bottom: 10px; color: #333; font-size: 1.1em; }
.filter-option { margin-bottom: 10px; }
.filter-option label { font-size: 0.9em; color: #555; }
.noise-stats { font-size: 0.8em; color: #666; margin-top: 10px; }
#status { padding: 15px; border-radius: 8px; font-weight: bold; background: #e8f5e8; color: #2e7d2e; margin-top: 20px; font-size: 1.1em; }
.device-quality { font-size: 12px; color: #666; margin-top: 5px; }
.advanced-mode { margin-bottom: 20px; padding: 15px; background: #f5f5dc; border-radius: 10px; }
.advanced-mode h4 { margin-bottom: 10px; color: #333; font-size: 1.1em; }
.advanced-controls { margin-top: 15px; display: none; }
.compressor-control { margin-bottom: 10px; }
.compressor-control label { display: block; font-size: 0.9em; color: #555; margin-bottom: 5px; }
.compressor-control input[type="range"] { width: 100%; height: 6px; background: #ddd; outline: none; border-radius: 3px; margin-bottom: 5px; }
.compressor-control input[type="range"]::-webkit-slider-thumb { appearance: none; width: 18px; height: 18px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
.compressor-display { font-size: 0.85em; color: #666; margin-bottom: 10px; }
.ai-status { font-size: 0.8em; color: #666; margin-top: 10px; padding: 10px; background: #f0f8ff; border-radius: 5px; display: block !important; }
@media (max-width: 480px) { body { padding: 10px; } .container { padding: 20px; } h1 { font-size: 1.5em; } button { padding: 12px 20px; font-size: 14px; margin: 5px; } }
</style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”Š ë³´ì²­ê¸° ì›¹ì•± Phase 2.0</h1>
    
    <div id="permissionGuide" class="permission-guide">
      <strong>ğŸ“± ë§ˆì´í¬ ê¶Œí•œ í—ˆìš© ë°©ë²•:</strong><br>
      1. ì£¼ì†Œì°½ ì¢Œì¸¡ ğŸ”’ ì•„ì´ì½˜ í´ë¦­<br>
      2. "ë§ˆì´í¬" â†’ "í—ˆìš©" ì„ íƒ<br>
      3. í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„
    </div>
    
    <div class="controls">
      <button id="permissionBtn" class="permission-btn">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
      <button id="startButton">ì‹œì‘</button>
      <button id="stopButton">ì •ì§€</button>
    </div>
    
    <div class="mic-selection">
      <label for="micSelect">ğŸ¤ ë§ˆì´í¬ ì„ íƒ:</label>
      <select id="micSelect">
        <option value="">ê¸°ë³¸ ë§ˆì´í¬</option>
      </select>
      <div id="micQuality" class="device-quality"></div>
    </div>
    
    <div class="volume-control">
      <label for="volumeSlider">ğŸ”Š ë³¼ë¥¨ (ì•ˆì „ ì¦í­):</label>
      <input type="range" id="volumeSlider" min="0" max="100" value="50">
      <div>
        <span id="volumeDisplay">50</span>% 
        <span id="amplificationLevel" class="amplification-info">(1.5ë°° ì¦í­)</span>
        <span id="safetyIndicator" class="safety-indicator" style="background-color: green;"></span>
      </div>
    </div>
    
    <div class="noise-filter-control" id="noiseFilterControl">
      <h4>ğŸ”‡ ë…¸ì´ì¦ˆ í•„í„°</h4>
      <div class="filter-option">
        <label><input type="checkbox" id="powerNoiseFilter" checked> ì „ì› ë…¸ì´ì¦ˆ ì œê±° (60Hz)</label>
      </div>
      <div class="filter-option">
        <label><input type="checkbox" id="highFreqFilter" checked> ê³ ì£¼íŒŒ ì¡ìŒ ì œê±° (4kHz+)</label>
      </div>
      <div class="noise-stats">
        <div>í˜„ì¬ ë…¸ì´ì¦ˆ: <span id="noiseLevel">-âˆ dB</span></div>
        <div>í•„í„° íš¨ê³¼: <span id="filterEffectiveness">0% ê°ì†Œ</span></div>
      </div>
    </div>
    
    <div class="advanced-mode" id="advancedModeControl">
      <h4>ğŸš€ ê³ ê¸‰ ëª¨ë“œ</h4>
      <div class="filter-option">
        <label><input type="checkbox" id="advancedModeCheckbox"> ê³ ê¸‰ ëª¨ë“œ í™œì„±í™”</label>
      </div>
      <div class="advanced-controls" id="advancedControls">
        <div class="compressor-control">
          <label for="thresholdSlider">ğŸ“Š Threshold:</label>
          <input type="range" id="thresholdSlider" min="-30" max="-10" value="-20" step="1">
          <div class="compressor-display">ê°’: <span id="thresholdDisplay">-20dB</span></div>
        </div>
        <div class="compressor-control">
          <label for="ratioSlider">âš–ï¸ Ratio:</label>
          <input type="range" id="ratioSlider" min="2" max="12" value="4" step="1">
          <div class="compressor-display">ê°’: <span id="ratioDisplay">4:1</span></div>
        </div>
        <div class="compressor-control">
          <label for="attackSlider">âš¡ Attack:</label>
          <input type="range" id="attackSlider" min="0.001" max="0.1" value="0.01" step="0.001">
          <div class="compressor-display">ê°’: <span id="attackDisplay">0.01s</span></div>
        </div>
        <div class="compressor-control">
          <label for="releaseSlider">â° Release:</label>
          <input type="range" id="releaseSlider" min="0.01" max="1.0" value="0.1" step="0.01">
          <div class="compressor-display">ê°’: <span id="releaseDisplay">0.1s</span></div>
        </div>
        <div class="compressor-control">
          <label>
            <input type="checkbox" id="autoQCheckbox" checked> ğŸ¤– ìë™ Qê°’ ì œì–´
          </label>
        </div>
        <div class="compressor-control" id="manualQMinControl" style="display:none;">
          <label for="minQSlider">ğŸ”¹ ìµœì†Œ Qê°’ (ì¡°ìš©í•œ í™˜ê²½):</label>
          <input type="range" id="minQSlider" min="1" max="50" value="5" step="0.5">
          <div class="compressor-display">ê°’: <span id="minQDisplay">5</span></div>
        </div>
        <div class="compressor-control" id="manualQMaxControl" style="display:none;">
          <label for="maxQSlider">ğŸ”¸ ìµœëŒ€ Qê°’ (ì‹œë„ëŸ¬ìš´ í™˜ê²½):</label>
          <input type="range" id="maxQSlider" min="1" max="100" value="50" step="1">
          <div class="compressor-display">ê°’: <span id="maxQDisplay">50</span></div>
        </div>
        <div class="ai-status" style="display: block !important;">
          <div>ğŸšï¸ ì••ì¶•ëŸ‰: <span id="compressionAmount">0%</span></div>
          <div>ğŸŒ í™˜ê²½: <span id="environmentType">ì¸¡ì • ì¤‘</span></div>
          <div>ğŸ§  ì ì‘ì  í•„í„° ê°•ë„: <span id="adaptiveStrength">0%</span></div>
        </div>
      </div>
    </div>

    <div id="status">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œì„ ìš”ì²­í•´ì£¼ì„¸ìš”</div>
  </div>

<script>
const permissionBtn = document.getElementById('permissionBtn');
const startButton = document.getElementById('startButton');
const stopButton = document.getElementById('stopButton');
const volumeSlider = document.getElementById('volumeSlider');
const volumeDisplay = document.getElementById('volumeDisplay');
const statusDiv = document.getElementById('status');
const permissionGuide = document.getElementById('permissionGuide');
const micSelect = document.getElementById('micSelect');
const micQuality = document.getElementById('micQuality');

// Phase 2.0: ê³ ê¸‰ëª¨ë“œ ì»¨íŠ¸ë¡¤ ìš”ì†Œë“¤
const advancedModeCheckbox = document.getElementById('advancedModeCheckbox');
const advancedControls = document.getElementById('advancedControls');
const thresholdSlider = document.getElementById('thresholdSlider');
const ratioSlider = document.getElementById('ratioSlider');
const attackSlider = document.getElementById('attackSlider');
const releaseSlider = document.getElementById('releaseSlider');
const thresholdDisplay = document.getElementById('thresholdDisplay');
const ratioDisplay = document.getElementById('ratioDisplay');
const attackDisplay = document.getElementById('attackDisplay');
const releaseDisplay = document.getElementById('releaseDisplay');
const compressionAmount = document.getElementById('compressionAmount');
const environmentType = document.getElementById('environmentType');
const adaptiveStrength = document.getElementById('adaptiveStrength');

// ìë™/ìˆ˜ë™ Qê°’ ì œì–´ ìš”ì†Œë“¤ (ìƒˆë¡œ ì¶”ê°€)
const autoQCheckbox = document.getElementById('autoQCheckbox');
const minQSlider = document.getElementById('minQSlider');
const maxQSlider = document.getElementById('maxQSlider');
const minQDisplay = document.getElementById('minQDisplay');
const maxQDisplay = document.getElementById('maxQDisplay');
const manualQMinControl = document.getElementById('manualQMinControl');
const manualQMaxControl = document.getElementById('manualQMaxControl');

let audioContext, microphoneStream, gainNode, highpassFilter, source, isRunning = false;
let notchFilter60Hz, lowpassFilter4kHz, analyserNode; // Phase 1.9 ì¶”ê°€ í•„í„°ë“¤
let compressorNode, analyserEnv, adaptiveFilterStrength = 0; // Phase 2.0 ê³ ê¸‰ëª¨ë“œ ë³€ìˆ˜ë“¤
let hasPermission = false;
let wakeLock = null;
let wasRunningBeforeHidden = false;
let selectedMicrophoneId = null;
let failoverAttempts = 0;
const MAX_FAILOVER_ATTEMPTS = 3;

// ìë™/ìˆ˜ë™ Qê°’ ì œì–´ ë³€ìˆ˜ë“¤ (ìƒˆë¡œ ì¶”ê°€)
let minQValue = 5;
let maxQValue = 50;
let autoQEnabled = true;

// ì´ˆê¸° ìƒíƒœ ì„¤ì •
startButton.disabled = true;
stopButton.disabled = true;

// Phase 2.0: ê³ ê¸‰ëª¨ë“œ ì´ˆê¸° ì„¤ì • - í† ê¸€ì€ ë³´ì´ê³  ì»¨íŠ¸ë¡¤ë§Œ ìˆ¨ê¹€
advancedControls.style.display = 'none';

// Phase 1.7: ì‹¤ì‹œê°„ ì¥ì¹˜ ê°ì§€ ë° ì•ˆì •ì„± ê°•í™”

// ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦ í•¨ìˆ˜
async function validateAudioStream(stream) {
  try {
    const tracks = stream.getAudioTracks();
    if (tracks.length === 0) {
      throw new Error('ì˜¤ë””ì˜¤ íŠ¸ë™ì´ ì—†ìŠµë‹ˆë‹¤');
    }
    
    const track = tracks[0];
    const settings = track.getSettings();
    
    // íŠ¸ë™ ìƒíƒœ í™•ì¸
    if (track.readyState !== 'live') {
      throw new Error(`íŠ¸ë™ ìƒíƒœ ì´ìƒ: ${track.readyState}`);
    }
    
    // í’ˆì§ˆ ì •ë³´ í‘œì‹œ
    const sampleRate = settings.sampleRate || 'N/A';
    const channelCount = settings.channelCount || 'N/A';
    
    micQuality.innerHTML = `
      ğŸ“Š í’ˆì§ˆ: ${sampleRate}Hz, ${channelCount}ì±„ë„
      <br>ğŸ“¶ ìƒíƒœ: ${track.enabled ? 'í™œì„±' : 'ë¹„í™œì„±'}
    `;
    
    console.log('ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦ ì™„ë£Œ:', settings);
    return true;
    
  } catch (err) {
    console.error('ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦ ì‹¤íŒ¨:', err);
    micQuality.textContent = 'âŒ í’ˆì§ˆ ê²€ì¦ ì‹¤íŒ¨';
    return false;
  }
}

// ìŠ¤ë§ˆíŠ¸ ë³µêµ¬ ì‹œìŠ¤í…œ
async function attemptSmartRecovery(originalDeviceId) {
  const fallbackOptions = [
    { id: null, name: 'ê¸°ë³¸ ë§ˆì´í¬' },
    { id: 'first-available', name: 'ì²«ë²ˆì§¸ ê°€ìš© ë§ˆì´í¬' }
  ];
  
  for (const option of fallbackOptions) {
    try {
      console.log(`ë³µêµ¬ ì‹œë„ ${failoverAttempts + 1}/${MAX_FAILOVER_ATTEMPTS}: ${option.name}`);
      
      let deviceId = option.id;
      if (deviceId === 'first-available') {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = devices.filter(device => device.kind === 'audioinput');
        deviceId = audioInputs.length > 0 ? audioInputs[0].deviceId : null;
      }
      
      await switchMicrophone(deviceId, true); // skipFailover = true
      failoverAttempts = 0; // ì„±ê³µ ì‹œ ì´ˆê¸°í™”
      return true;
      
    } catch (err) {
      console.error(`ë³µêµ¬ ì‹¤íŒ¨ (${option.name}):`, err);
      continue;
    }
  }
  
  failoverAttempts = 0;
  statusDiv.textContent = 'âŒ ëª¨ë“  ë³µêµ¬ ì‹œë„ ì‹¤íŒ¨ - ê¶Œí•œ ì¬ìš”ì²­ í•„ìš”';
  statusDiv.style.background = '#f8d7da';
  statusDiv.style.color = '#721c24';
  
  // ê¶Œí•œ ë²„íŠ¼ ë‹¤ì‹œ í™œì„±í™”
  permissionBtn.disabled = false;
  startButton.disabled = true;
  
  return false;
}

// ë§ˆì´í¬ ëª©ë¡ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ê°œì„ ë¨)
async function updateMicrophoneList() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(device => device.kind === 'audioinput');
    
    // ê¸°ì¡´ ì˜µì…˜ ì œê±° (ê¸°ë³¸ ì˜µì…˜ ì œì™¸)
    while (micSelect.children.length > 1) {
      micSelect.removeChild(micSelect.lastChild);
    }
    
    if (audioInputs.length === 0) {
      console.warn('ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ê°€ ì—†ìŠµë‹ˆë‹¤');
      return;
    }
    
    let wirelessDeviceDetected = false;
    
    audioInputs.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      
      // ê¸°ê¸° íƒ€ì… ìë™ ì¸ì‹ ë° ì•„ì´ì½˜ ì¶”ê°€
      let deviceName = device.label || `ë§ˆì´í¬ ${index + 1}`;
      let icon = 'ğŸ¤';
      
      const lowerName = deviceName.toLowerCase();
      
      // ë¬´ì„  ì¥ì¹˜ ê°ì§€
      if (lowerName.includes('bluetooth') || lowerName.includes('wireless') || 
          lowerName.includes('airpods') || lowerName.includes('buds') || 
          lowerName.includes('headset')) {
        wirelessDeviceDetected = true;
        icon = 'ğŸ“¡';
        deviceName = `ë¬´ì„  ë§ˆì´í¬: ${deviceName}`;
      } else if (lowerName.includes('built-in') || lowerName.includes('internal') || lowerName.includes('default')) {
        icon = 'ğŸ“±';
        deviceName = `ë‚´ì¥ ë§ˆì´í¬: ${deviceName}`;
      } else if (lowerName.includes('headphone') || lowerName.includes('earphone')) {
        icon = 'ğŸ§';
        deviceName = `ì´ì–´í° ë§ˆì´í¬: ${deviceName}`;
      } else if (lowerName.includes('usb') || lowerName.includes('external') || lowerName.includes('webcam')) {
        icon = 'ğŸ–¥ï¸';
        deviceName = `ì™¸ì¥ ë§ˆì´í¬: ${deviceName}`;
      }
      
      option.text = `${icon} ${deviceName}`;
      micSelect.appendChild(option);
    });
    
    // ë¬´ì„  ì¥ì¹˜ ê²½ê³ 
    if (wirelessDeviceDetected && !isRunning) {
      statusDiv.textContent = 'âš ï¸ ë¬´ì„ ì´ì–´í° ê°ì§€: ì§€ì—°ì‹œê°„(160ms+) ë°œìƒ ê°€ëŠ¥. ìœ ì„  ì´ì–´í° ê¶Œì¥';
      statusDiv.style.background = '#fff3cd';
      statusDiv.style.color = '#856404';
    }
    
    console.log(`ë°œê²¬ëœ ë§ˆì´í¬ ${audioInputs.length}ê°œ (ë¬´ì„ : ${wirelessDeviceDetected ? 'O' : 'X'})`);
    document.querySelector('.mic-selection').style.display = 'block';
    
  } catch (err) {
    console.error('ë§ˆì´í¬ ëª©ë¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', err);
    statusDiv.textContent = 'âš ï¸ ë§ˆì´í¬ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
  }
}

// ì‹¤ì‹œê°„ ë§ˆì´í¬ ì „í™˜ í•¨ìˆ˜ (ê°œì„ ë¨)
async function switchMicrophone(deviceId, skipFailover = false) {
  if (!isRunning) return;
  
  try {
    console.log('ë§ˆì´í¬ ì „í™˜ ì‹œì‘:', deviceId);
    statusDiv.textContent = 'ğŸ”„ ë§ˆì´í¬ ì „í™˜ ì¤‘...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    // í˜„ì¬ ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ ì •ì§€
    if (microphoneStream) {
      microphoneStream.getTracks().forEach(track => track.stop());
    }
    
    // ìƒˆ ë§ˆì´í¬ë¡œ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    const constraints = {
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    };
    
    if (deviceId) {
      constraints.audio.deviceId = { exact: deviceId };
    }
    
    microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    // ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦
    const isValid = await validateAudioStream(microphoneStream);
    if (!isValid) {
      throw new Error('ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦ ì‹¤íŒ¨');
    }
    
    // ê¸°ì¡´ ì˜¤ë””ì˜¤ ë…¸ë“œ ì—°ê²° í•´ì œ
    if (source) {
      source.disconnect();
    }
    
    // Phase 2.0: ìƒˆ ì†ŒìŠ¤ë¡œ ë‹¤ì‹œ ì—°ê²° (ê³ ê¸‰ëª¨ë“œ ê³ ë ¤)
    source = audioContext.createMediaStreamSource(microphoneStream);
    connectAudioChain();
    
    console.log('ë§ˆì´í¬ ì „í™˜ ì™„ë£Œ');
    statusDiv.textContent = 'ğŸ”Š ë³´ì²­ê¸° ì‘ë™ ì¤‘ (ì´ì–´í° ì°©ìš© ê¶Œì¥)';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    failoverAttempts = 0; // ì„±ê³µ ì‹œ ì´ˆê¸°í™”
    
  } catch (err) {
    console.error('ë§ˆì´í¬ ì „í™˜ ì‹¤íŒ¨:', err);
    statusDiv.textContent = `âŒ ë§ˆì´í¬ ì „í™˜ ì‹¤íŒ¨: ${err.message}`;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
      failoverAttempts++;
      
      if (!skipFailover && failoverAttempts <= MAX_FAILOVER_ATTEMPTS) {
      statusDiv.textContent = `âŒ ë§ˆì´í¬ ì „í™˜ ì‹¤íŒ¨ (${failoverAttempts}/${MAX_FAILOVER_ATTEMPTS}) - ë³µêµ¬ ì¤‘...`;
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.color = '#721c24';
      
      // ìŠ¤ë§ˆíŠ¸ ë³µêµ¬ ì‹œë„
      setTimeout(() => attemptSmartRecovery(deviceId), 1000);
    } else {
      statusDiv.textContent = 'âŒ ë§ˆì´í¬ ì „í™˜ ìµœì¢… ì‹¤íŒ¨';
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.color = '#721c24';
      
      if (!skipFailover) {
        await attemptSmartRecovery(deviceId);
      }
    }
  }
}

// ì‹¤ì‹œê°„ ì¥ì¹˜ ë³€ê²½ ê°ì§€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
navigator.mediaDevices.addEventListener('devicechange', () => {
  console.log('ì¥ì¹˜ ë³€ê²½ ê°ì§€ - ë§ˆì´í¬ ëª©ë¡ ì—…ë°ì´íŠ¸');
  setTimeout(updateMicrophoneList, 500); // 500ms ì§€ì—°ìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´
});

// 1ë‹¨ê³„: ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­
permissionBtn.addEventListener('click', async () => {
  try {
    statusDiv.textContent = 'ğŸ”„ ë§ˆì´í¬ ê¶Œí•œ í™•ì¸ ì¤‘...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    
    // ê¶Œí•œ ì„±ê³µ - ì„ì‹œ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
    stream.getTracks().forEach(track => track.stop());
    hasPermission = true;
    
    statusDiv.textContent = 'âœ… ë§ˆì´í¬ ê¶Œí•œ í—ˆìš©ë¨ - ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ê³  ì‹œì‘í•˜ì„¸ìš”';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    permissionBtn.disabled = true;
    startButton.disabled = false;
    permissionGuide.style.display = 'none';
    
    // ë§ˆì´í¬ ëª©ë¡ ì—…ë°ì´íŠ¸
    await updateMicrophoneList();
    
  } catch (err) {
    let errorMessage = 'âŒ ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨: ';
    if (err.name === 'NotAllowedError') {
      errorMessage += 'ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
    } else if (err.name === 'NotFoundError') {
      errorMessage += 'ë§ˆì´í¬ ì¥ì¹˜ê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += 'ì§€ì›ë˜ì§€ ì•ŠëŠ” ë§ˆì´í¬ ì„¤ì •ì…ë‹ˆë‹¤.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('ê¶Œí•œ ì˜¤ë¥˜:', err);
  }
});

// 2ë‹¨ê³„: ë³´ì²­ê¸° ì‹œì‘ (ë§ˆì´í¬ ì„ íƒ ì§€ì›)
startButton.addEventListener('click', async () => {
  try {
    statusDiv.textContent = 'ğŸš€ ë³´ì²­ê¸° ì‹œì‘ ì¤‘...';
    statusDiv.style.background = '#fff3cd';
    statusDiv.style.color = '#856404';
    
    // ì„ íƒëœ ë§ˆì´í¬ ì„¤ì •
    const constraints = {
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    };
    
    if (selectedMicrophoneId) {
      constraints.audio.deviceId = { exact: selectedMicrophoneId };
    }
    
    microphoneStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    // ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦
    const isValid = await validateAudioStream(microphoneStream);
    if (!isValid) {
      throw new Error('ë§ˆì´í¬ í’ˆì§ˆ ê²€ì¦ ì‹¤íŒ¨');
    }
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    console.log("AudioContext initial state:", audioContext.state); 
    if (audioContext.state === 'suspended') {
        console.log("Attempting to resume AudioContext...");
        await audioContext.resume();
        console.log("AudioContext state after resume:", audioContext.state); 
    }

    source = audioContext.createMediaStreamSource(microphoneStream);
    gainNode = audioContext.createGain();
    highpassFilter = audioContext.createBiquadFilter();
    highpassFilter.type = 'highpass';
    highpassFilter.frequency.setValueAtTime(100, audioContext.currentTime); 

    const volume = volumeSlider.value / 100;
    gainNode.gain.value = volume * 3; // Phase 1.9: 3ë°° ì•ˆì „ ì¦í­
    
    // ì‹¤ì‹œê°„ ì¦í­ ë ˆë²¨ í‘œì‹œ ì—…ë°ì´íŠ¸
    updateAmplificationDisplay(volume * 3);

    // Phase 1.9: ë…¸ì´ì¦ˆ í•„í„° ì¶”ê°€
    notchFilter60Hz = audioContext.createBiquadFilter();
    notchFilter60Hz.type = 'notch';
    notchFilter60Hz.frequency.setValueAtTime(60, audioContext.currentTime);
    notchFilter60Hz.Q.setValueAtTime(10, audioContext.currentTime);
    
    lowpassFilter4kHz = audioContext.createBiquadFilter();
    lowpassFilter4kHz.type = 'lowpass';
    lowpassFilter4kHz.frequency.setValueAtTime(4000, audioContext.currentTime);
    
    analyserNode = audioContext.createAnalyser();
    analyserNode.fftSize = 256;
    
    // Phase 2.0: ì˜¤ë””ì˜¤ ì²´ì¸ ì—°ê²° (ê³ ê¸‰ëª¨ë“œ ê³ ë ¤)
    connectAudioChain();
    
    // ë…¸ì´ì¦ˆ ë ˆë²¨ ëª¨ë‹ˆí„°ë§ ì‹œì‘
    startNoiseMonitoring();
    
    // Phase 2.0: ê³ ê¸‰ëª¨ë“œ ì„¤ì • ì ìš©
    if (advancedModeCheckbox.checked) {
      await setupAdvancedMode();
    }
    
    startButton.disabled = true;
    stopButton.disabled = false;
    isRunning = true;
    
    statusDiv.textContent = 'ğŸ”Š ë³´ì²­ê¸° ì‘ë™ ì¤‘ (ì´ì–´í° ì°©ìš© ê¶Œì¥)';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.color = '#155724';
    
    // Wake Lock API ì‚¬ìš© (ì§€ì›í•˜ëŠ” ë¸Œë¼ìš°ì €ì—ì„œ)
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock acquired');
      } catch (err) {
        console.error('Wake Lock request failed:', err);
      }
    }

  } catch (err) {
    let errorMessage = 'âŒ ë³´ì²­ê¸° ì‹œì‘ ì‹¤íŒ¨: ';
    if (err.name === 'NotAllowedError') {
        errorMessage += 'ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.';
    } else if (err.name === 'NotFoundError'){
        errorMessage += 'AudioContextê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
    } else if (err.name === 'OverconstrainedError'){
        errorMessage += 'ì§€ì›ë˜ì§€ ì•ŠëŠ” ë§ˆì´í¬ ì„¤ì •ì…ë‹ˆë‹¤.';
    } else {
      errorMessage += err.message;
    }
    statusDiv.textContent = errorMessage;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.color = '#721c24';
    permissionGuide.style.display = 'block';
    console.error('ë³´ì²­ê¸° ì‹œì‘ ì˜¤ë¥˜:', err);
  }
});

// 3ë‹¨ê³„: ë³´ì²­ê¸° ì •ì§€ (ìˆ˜ì •ë¨ - suspend ì‚¬ìš©)
stopButton.addEventListener('click', async () => {
  // ë§ˆì´í¬ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
    microphoneStream = null;
  }
  
  // ì˜¤ë””ì˜¤ ë…¸ë“œë“¤ ëª…ì‹œì  í•´ì œ
  if (source) {
    source.disconnect();
    source = null;
  }
  if (gainNode) {
    gainNode.disconnect();
    gainNode = null;
  }
  if (highpassFilter) {
    highpassFilter.disconnect();
    highpassFilter = null;
  }
  if (notchFilter60Hz) {
    notchFilter60Hz.disconnect();
    notchFilter60Hz = null;
  }
  if (lowpassFilter4kHz) {
    lowpassFilter4kHz.disconnect();
    lowpassFilter4kHz = null;
  }
  if (analyserNode) {
    analyserNode.disconnect();
    analyserNode = null;
  }
  
  // AudioContext suspend (ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡)
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
      console.log('AudioContext suspended (reusable)');
    } catch (err) {
      console.error('AudioContext suspend failed:', err);
    }
  }
  
  // Wake Lock í•´ì œ
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    console.log('Wake Lock released');
  }
  
  // í’ˆì§ˆ ì •ë³´ ì´ˆê¸°í™”
  micQuality.textContent = '';
  
  startButton.disabled = false;
  stopButton.disabled = true;
  isRunning = false;
  
  statusDiv.textContent = 'â¹ï¸ ë³´ì²­ê¸° ì •ì§€ë¨ (ì¬ì‹œì‘ ê°€ëŠ¥)';
  statusDiv.style.background = '#f8d7da';
  statusDiv.style.color = '#721c24';
});

// ë§ˆì´í¬ ì„ íƒ ë³€ê²½ ì´ë²¤íŠ¸
micSelect.addEventListener('change', async function() {
  selectedMicrophoneId = this.value || null;
  console.log('ë§ˆì´í¬ ì„ íƒ ë³€ê²½:', selectedMicrophoneId);
  
  if (isRunning) {
    await switchMicrophone(selectedMicrophoneId);
  }
});

// Phase 1.9: ë³¼ë¥¨ ì¡°ì ˆ ê°œì„ 
volumeSlider.addEventListener('input', function() {
  const volume = this.value / 100;
  volumeDisplay.textContent = this.value;
  
  if (gainNode && isRunning) {
    gainNode.gain.value = volume * 3; // 3ë°° ì¦í­
    updateAmplificationDisplay(volume * 3);
    updateSafetyIndicator(volume * 3);
  }
});

// Phase 1.9: ë…¸ì´ì¦ˆ í•„í„° ì œì–´
document.getElementById('powerNoiseFilter').addEventListener('change', function() {
  if (notchFilter60Hz) {
    // ì²´í¬ ìƒíƒœì— ë”°ë¥¸ í•„í„° í™œì„±í™”/ë¹„í™œì„±í™”
    if (this.checked) {
      notchFilter60Hz.frequency.setValueAtTime(60, audioContext.currentTime);
    } else {
      notchFilter60Hz.frequency.setValueAtTime(22050, audioContext.currentTime); // ë¹„í™œì„±í™”
    }
    updateFilterEffectiveness();
  }
});

// Phase 2.0: ê³ ê¸‰ëª¨ë“œ í† ê¸€ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ìˆ˜ì •ë¨ - ì²´ì¸ ì¬ì—°ê²° ë¡œì§ ê°•í™”)
advancedModeCheckbox.addEventListener('change', function() {
  console.log(`ğŸ”§ Advanced mode toggled: ${this.checked ? 'ON' : 'OFF'}`);
  
  if (this.checked) {
    // ê³ ê¸‰ëª¨ë“œ í™œì„±í™”
    advancedControls.style.display = 'block';
    if (isRunning && audioContext) {
      console.log('ğŸš€ Setting up advanced mode...');
      setupAdvancedMode().then(() => {
        console.log('âœ… Advanced mode setup complete');
      }).catch(err => {
        console.error('âŒ Advanced mode setup failed:', err);
      });
    }
  } else {
    // ê³ ê¸‰ëª¨ë“œ ë¹„í™œì„±í™”
    advancedControls.style.display = 'none';
    console.log('ğŸ“¡ Switching to basic mode...');
    
    // ê³ ê¸‰ëª¨ë“œ ì „ìš© ë…¸ë“œë“¤ ì •ë¦¬
    try {
      if (compressorNode) {
        compressorNode.disconnect();
        compressorNode = null;
        console.log('ğŸ—‘ï¸ Compressor node cleaned up');
      }
      if (analyserEnv) {
        analyserEnv.disconnect();
        analyserEnv = null;
        console.log('ğŸ—‘ï¸ Environment analyser cleaned up');
      }
    } catch (err) {
      console.warn('âš ï¸ Cleanup warning:', err.message);
    }
    
    // ê¸°ë³¸ëª¨ë“œë¡œ ì²´ì¸ ì¬ì—°ê²°
    if (isRunning && source) {
      const reconnected = connectAudioChain();
      if (reconnected) {
        console.log('âœ… Switched to basic mode successfully');
      } else {
        console.error('âŒ Failed to reconnect in basic mode');
      }
    }
  }
});

// Phase 2.0: ì»´í”„ë ˆì„œ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
thresholdSlider.addEventListener('input', updateCompressorSettings);
ratioSlider.addEventListener('input', updateCompressorSettings);
attackSlider.addEventListener('input', updateCompressorSettings);
releaseSlider.addEventListener('input', updateCompressorSettings);

// ìë™/ìˆ˜ë™ Qê°’ ì œì–´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ìƒˆë¡œ ì¶”ê°€)
autoQCheckbox.addEventListener('change', function() {
  autoQEnabled = this.checked;
  const displayStyle = autoQEnabled ? 'none' : 'block';
  manualQMinControl.style.display = displayStyle;
  manualQMaxControl.style.display = displayStyle;
  
  console.log('ğŸ”„ Qê°’ ì œì–´ ëª¨ë“œ ë³€ê²½:', autoQEnabled ? 'ìë™' : 'ìˆ˜ë™');
  
  // ìˆ˜ë™ ëª¨ë“œë¡œ ì „í™˜ ì‹œ ì¦‰ì‹œ Qê°’ ì ìš©
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
    console.log('ìˆ˜ë™ ëª¨ë“œë¡œ ì „í™˜ - ì¦‰ì‹œ Qê°’ ì ìš©');
  }
});

minQSlider.addEventListener('input', function() {
  minQValue = parseFloat(this.value);
  minQDisplay.textContent = minQValue;
  // ìµœì†Œê°’ì´ ìµœëŒ€ê°’ë³´ë‹¤ í¬ë©´ ìµœëŒ€ê°’ ì¡°ì •
  if (minQValue >= maxQValue) {
    maxQValue = minQValue + 1;
    maxQSlider.value = maxQValue;
    maxQDisplay.textContent = maxQValue;
  }
  
  // ìˆ˜ë™ ëª¨ë“œì—ì„œ ì‹¤ì‹œê°„ Qê°’ ì ìš©
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
  }
  
  console.log(`ìµœì†Œ Qê°’ ë³€ê²½: ${minQValue} (ìë™ëª¨ë“œ: ${autoQEnabled})`);
});

maxQSlider.addEventListener('input', function() {
  maxQValue = parseFloat(this.value);
  maxQDisplay.textContent = maxQValue;
  // ìµœëŒ€ê°’ì´ ìµœì†Œê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ìµœì†Œê°’ ì¡°ì •
  if (maxQValue <= minQValue) {
    minQValue = maxQValue - 1;
    minQSlider.value = minQValue;
    minQDisplay.textContent = minQValue;
  }
  
  // ìˆ˜ë™ ëª¨ë“œì—ì„œ ì‹¤ì‹œê°„ Qê°’ ì ìš©
  if (!autoQEnabled && notchFilter60Hz && isRunning) {
    applyManualQValue();
  }
  
  console.log(`ìµœëŒ€ Qê°’ ë³€ê²½: ${maxQValue} (ìë™ëª¨ë“œ: ${autoQEnabled})`);
});

// ìˆ˜ë™ ëª¨ë“œ Qê°’ ì‹¤ì‹œê°„ ì ìš© í•¨ìˆ˜ (ìƒˆë¡œ ì¶”ê°€)
function applyManualQValue() {
  if (!notchFilter60Hz || !document.getElementById('powerNoiseFilter').checked) {
    console.log('ìˆ˜ë™ Qê°’ ì ìš© ì‹œí: í•„í„° ë¹„í™œì„±í™”');
    return;
  }
  
  // ìˆ˜ë™ ëª¨ë“œì—ì„œëŠ” ìµœì†Œ Qê°’ ì‚¬ìš© (ì‚¬ìš©ìê°€ ì§ì ‘ ì œì–´)
  const qValue = Math.min(Math.max(minQValue, 1), 100);
  
  try {
    notchFilter60Hz.Q.linearRampToValueAtTime(qValue, audioContext.currentTime + 0.1);
    console.log(`ğŸ”§ ìˆ˜ë™ Qê°’ ì ìš©: ${qValue} (ë²”ìœ„: ${minQValue}-${maxQValue})`);
    
    // ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
    if (adaptiveStrength) {
      adaptiveStrength.textContent = `Q: ${minQValue}-${maxQValue}`;
    }
  } catch (err) {
    console.error('ìˆ˜ë™ Qê°’ ì ìš© ì‹¤íŒ¨:', err);
  }
}

// Phase 2.0: ê³ ê¸‰ëª¨ë“œ ì„¤ì • í•¨ìˆ˜ (ìˆ˜ì •ë¨ - ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”)
async function setupAdvancedMode() {
  try {
    if (!audioContext) {
      console.error('âŒ AudioContext not available for advanced mode');
      return false;
    }
    
    if (audioContext.state !== 'running') {
      console.warn('âš ï¸ AudioContext not running, attempting to resume...');
      await audioContext.resume();
    }
    
    console.log('ğŸ—ï¸ Creating advanced mode nodes...');
    
    // ì»´í”„ë ˆì„œ ë…¸ë“œ ìƒì„±
    compressorNode = audioContext.createDynamicsCompressor();
    analyserEnv = audioContext.createAnalyser();
    analyserEnv.fftSize = 256;
    
    console.log('ğŸ›ï¸ Advanced nodes created successfully');
    
    // ì´ˆê¸° ì»´í”„ë ˆì„œ ì„¤ì •
    updateCompressorSettings();
    
    // ì˜¤ë””ì˜¤ ì²´ì¸ ì¬ì—°ê²°
    const chainConnected = connectAudioChain();
    if (!chainConnected) {
      throw new Error('Failed to connect advanced audio chain');
    }
    
    // ëª¨ë‹ˆí„°ë§ ì‹œì‘
    if (isRunning) {
      startAdvancedMonitoring();
      console.log('ğŸ“Š Advanced monitoring started');
    }
    
    return true;
    
  } catch (err) {
    console.error('âŒ Advanced mode setup failed:', err);
    
    // ì‹¤íŒ¨ ì‹œ ì •ë¦¬
    if (compressorNode) {
      compressorNode.disconnect();
      compressorNode = null;
    }
    if (analyserEnv) {
      analyserEnv.disconnect();
      analyserEnv = null;
    }
    
    return false;
  }
}

// Phase 2.0: ì»´í”„ë ˆì„œ ì„¤ì • ì—…ë°ì´íŠ¸ (ìˆ˜ì •ë¨ - linearRampToValueAtTime ì‚¬ìš©)
function updateCompressorSettings() {
  // compressorNode ì¡´ì¬ ë° ì—°ê²° ìƒíƒœ í™•ì¸
  if (!compressorNode) {
    console.warn('âš ï¸ Compressor node not initialized. Advanced Mode may be disabled.');
    return;
  }
  
  if (!audioContext || audioContext.state !== 'running') {
    console.warn('âš ï¸ AudioContext not running. Current state:', audioContext ? audioContext.state : 'null');
    return;
  }
  
  const threshold = parseFloat(thresholdSlider.value);
  const ratio = parseFloat(ratioSlider.value);
  const attack = parseFloat(attackSlider.value);
  const release = parseFloat(releaseSlider.value);
  
  // linearRampToValueAtTime ì‚¬ìš©ìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ ì „í™˜ (0.1ì´ˆ)
  const currentTime = audioContext.currentTime;
  const rampTime = 0.1;
  
  try {
    compressorNode.threshold.linearRampToValueAtTime(threshold, currentTime + rampTime);
    compressorNode.ratio.linearRampToValueAtTime(ratio, currentTime + rampTime);
    compressorNode.attack.linearRampToValueAtTime(attack, currentTime + rampTime);
    compressorNode.release.linearRampToValueAtTime(release, currentTime + rampTime);
    
    console.log(`ğŸ›ï¸ Compressor settings updated: T:${threshold}dB, R:${ratio}:1, A:${attack}s, Rel:${release}s`);
  } catch (err) {
    console.error('âŒ Failed to update compressor settings:', err);
  }
  
  // ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
  thresholdDisplay.textContent = `${threshold}dB`;
  ratioDisplay.textContent = `${ratio}:1`;
  attackDisplay.textContent = `${attack}s`;
  releaseDisplay.textContent = `${release}s`;
}

// Phase 2.0: ì˜¤ë””ì˜¤ ì²´ì¸ ì—°ê²° í•¨ìˆ˜ (ìˆ˜ì •ë¨ - ì—°ê²° ìƒíƒœ í™•ì¸ ë¡œì§ ì¶”ê°€)
function connectAudioChain() {
  console.log('ğŸ”— Connecting audio chain...');
  
  // í•„ìˆ˜ ë…¸ë“œë“¤ ì¡´ì¬ í™•ì¸
  if (!source) {
    console.error('âŒ Source node not ready');
    return false;
  }
  if (!notchFilter60Hz || !lowpassFilter4kHz || !highpassFilter || !gainNode || !analyserNode) {
    console.error('âŒ Required audio nodes not initialized');
    return false;
  }
  
  // ê¸°ì¡´ ì—°ê²° í•´ì œ
  try {
    source.disconnect();
    if (compressorNode) compressorNode.disconnect();
    if (analyserEnv) analyserEnv.disconnect();
    notchFilter60Hz.disconnect();
    lowpassFilter4kHz.disconnect();
    highpassFilter.disconnect();
    gainNode.disconnect();
    analyserNode.disconnect();
    console.log('ğŸ”„ Previous connections disconnected');
  } catch (err) {
    console.warn('âš ï¸ Some disconnections failed (normal on first run):', err.message);
  }
  
  try {
    // ìƒˆ ì²´ì¸ ì—°ê²° - ê³ ê¸‰ëª¨ë“œ í™•ì¸
    if (advancedModeCheckbox.checked && compressorNode && analyserEnv) {
      // ê³ ê¸‰ëª¨ë“œ: source -> analyserEnv -> compressor -> notch -> lowpass -> highpass -> gain -> analyser -> destination
      source.connect(analyserEnv);
      analyserEnv.connect(compressorNode);
      compressorNode.connect(notchFilter60Hz);
      console.log('ğŸš€ Advanced mode chain: source -> analyserEnv -> compressor -> filters -> gain -> output');
    } else {
      // ê¸°ë³¸ëª¨ë“œ: source -> notch -> lowpass -> highpass -> gain -> analyser -> destination
      source.connect(notchFilter60Hz);
      console.log('ğŸ“¡ Basic mode chain: source -> filters -> gain -> output');
    }
    
    // ê³µí†µ í•„í„° ì²´ì¸ ì—°ê²°
    notchFilter60Hz.connect(lowpassFilter4kHz);
    lowpassFilter4kHz.connect(highpassFilter);
    highpassFilter.connect(gainNode);
    gainNode.connect(analyserNode);
    analyserNode.connect(audioContext.destination);
    
    console.log('âœ… Audio chain connected successfully');
    return true;
  } catch (err) {
    console.error('âŒ Failed to connect audio chain:', err);
    return false;
  }
}

// Phase 2.0: ê³ ê¸‰ëª¨ë“œ ëª¨ë‹ˆí„°ë§ ì‹œì‘
function startAdvancedMonitoring() {
  if (!analyserEnv || !advancedModeCheckbox.checked) return;
  
  const bufferLength = analyserEnv.frequencyBinCount;
  const dataArray = new Float32Array(bufferLength); // Float ë°°ì—´ë¡œ ë³€ê²½
  const timeDataArray = new Float32Array(bufferLength);
  
  function updateAdvancedStats() {
    if (!isRunning || !analyserEnv || !advancedModeCheckbox.checked) return;
    
    console.log('ğŸ” ê³ ê¸‰ëª¨ë“œ ëª¨ë‹ˆí„°ë§ ì‘ë™ ì¤‘... ìë™ëª¨ë“œ:', autoQEnabled);
    
    // í™˜ê²½ ë¶„ì„ - ì˜¬ë°”ë¥¸ TimeDomain RMS ë…¸ì´ì¦ˆ ì¸¡ì •
    analyserEnv.getFloatTimeDomainData(timeDataArray);
    let rms = 0;
    for (let i = 0; i < timeDataArray.length; i++) {
      rms += timeDataArray[i] * timeDataArray[i];
    }
    rms = Math.sqrt(rms / timeDataArray.length);
    
    // dB ë³€í™˜ (ì˜¬ë°”ë¥¸ ê³µì‹)
    const noiseLevel = Math.round(20 * Math.log10(rms + 1e-10));
    
    console.log(`ğŸ”Š ì‹¤ì‹œê°„ ì¸¡ì • - RMS: ${rms.toFixed(4)}, ë…¸ì´ì¦ˆ ë ˆë²¨: ${noiseLevel}dB`);
    
    // í™˜ê²½ ë¶„ë¥˜ ë° ì ì‘ì  í•„í„° ê°•ë„ ì„¤ì • (ìˆ˜ë™ ëª¨ë“œ ê³ ë ¤)
    let environment = 'ì¸¡ì • ì¤‘';
    
    if (autoQEnabled) {
      // ìë™ ëª¨ë“œ: í˜„ì‹¤ì ì¸ í™˜ê²½ ë¶„ë¥˜ ê¸°ì¤€
      if (noiseLevel <= -60) {
        environment = 'ğŸ  ì¡°ìš©í•¨';
        adaptiveFilterStrength = 20;
      } else if (noiseLevel <= -40) {
        environment = 'ğŸ¢ ë³´í†µ';
        adaptiveFilterStrength = 50;
      } else {
        environment = 'ğŸš— ì‹œë„ëŸ¬ì›€';
        adaptiveFilterStrength = 80;
      }
      console.log(`ìë™ ëª¨ë“œ - ë…¸ì´ì¦ˆ: ${noiseLevel}dB, í™˜ê²½: ${environment}, ê°•ë„: ${adaptiveFilterStrength}%`);
    } else {
      // ìˆ˜ë™ ëª¨ë“œ: ê³ ì •ê°’ ì‚¬ìš©
      environment = 'ğŸ”§ ìˆ˜ë™ ì œì–´';
      adaptiveFilterStrength = 0; // ìˆ˜ë™ ëª¨ë“œì—ì„œëŠ” ê³ ì •
      console.log(`ìˆ˜ë™ ëª¨ë“œ - Qê°’ ë²”ìœ„: ${minQValue}-${maxQValue}`);
    }
    
    // ì••ì¶•ëŸ‰ ê³„ì‚° (í˜„ì‹¤ì  ì‹œë®¬ë ˆì´ì…˜)
    let compressionPercent = 0;
    if (compressorNode && advancedModeCheckbox.checked) {
      const threshold = parseFloat(thresholdSlider.value);
      const ratio = parseFloat(ratioSlider.value);
      
      // ì…ë ¥ ì‹ í˜¸ê°€ thresholdë¥¼ ë„˜ëŠ” ê²½ìš°ì—ë§Œ ì••ì¶• ë°œìƒ
      if (noiseLevel > threshold) {
        const excessLevel = noiseLevel - threshold;
        const compressedExcess = excessLevel / ratio;
        const reduction = excessLevel - compressedExcess;
        
        // ì••ì¶•ëŸ‰ì„ ë°±ë¶„ìœ¨ë¡œ ë³€í™˜ (ìµœëŒ€ 80%ë¡œ ì œí•œ)
        compressionPercent = Math.min(Math.round((reduction / Math.abs(excessLevel)) * 100), 80);
      }
      
      console.log(`ğŸ›ï¸ ì••ì¶• ê³„ì‚° - Threshold: ${threshold}dB, Input: ${noiseLevel}dB, ì••ì¶•ëŸ‰: ${compressionPercent}%`);
    }
    
    // ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸ (ëª¨ë“œë³„ ì²˜ë¦¬)
    environmentType.textContent = environment;
    
    if (autoQEnabled) {
      adaptiveStrength.textContent = `${adaptiveFilterStrength}%`;
    } else {
      // ìˆ˜ë™ ëª¨ë“œ: Qê°’ ë²”ìœ„ í‘œì‹œ
      adaptiveStrength.textContent = `Q: ${minQValue}-${maxQValue}`;
    }
    
    compressionAmount.textContent = `${compressionPercent}%`;
    console.log(`ğŸ“Š ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸ - í™˜ê²½: ${environment}, ì••ì¶•: ${compressionPercent}%`);
    
    // ì ì‘ì  í•„í„° ì ìš© (ìë™/ìˆ˜ë™ Qê°’ ì œì–´) - ê°œì„ ëœ ë¡œì§
    if (notchFilter60Hz && document.getElementById('powerNoiseFilter').checked) {
      let qValue;
      
      if (autoQEnabled) {
        // ìë™ ëª¨ë“œ: í™˜ê²½ì— ë”°ë¼ ì‚¬ìš©ì ì„¤ì • ë²”ìœ„ ë‚´ì—ì„œ ë™ì  ì¡°ì ˆ
        const qRange = maxQValue - minQValue;
        qValue = minQValue + (adaptiveFilterStrength / 100) * qRange;
        console.log(`ìë™ Qê°’: ${qValue.toFixed(1)} (í™˜ê²½: ${adaptiveFilterStrength}%)`);
      } else {
        // ìˆ˜ë™ ëª¨ë“œ: ìµœì†Œê°’ ê³ ì • ì‚¬ìš© (ì‚¬ìš©ìê°€ ì§ì ‘ ì œì–´)
        qValue = minQValue;
        console.log(`ìˆ˜ë™ Qê°’: ${qValue} (ê³ ì •)`);
      }
      
      // ì•ˆì „ ë²”ìœ„ ì œí•œ (1-100)
      qValue = Math.min(Math.max(qValue, 1), 100);
      notchFilter60Hz.Q.linearRampToValueAtTime(qValue, audioContext.currentTime + 0.1);
    }
    
    requestAnimationFrame(updateAdvancedStats);
  }
  
  updateAdvancedStats();
}

document.getElementById('highFreqFilter').addEventListener('change', function() {
  if (lowpassFilter4kHz) {
    if (this.checked) {
      lowpassFilter4kHz.frequency.setValueAtTime(4000, audioContext.currentTime);
    } else {
      lowpassFilter4kHz.frequency.setValueAtTime(22050, audioContext.currentTime); // ë¹„í™œì„±í™”
    }
    updateFilterEffectiveness();
  }
});

// Phase 1.9: ìƒˆë¡œìš´ í•¨ìˆ˜ë“¤
function updateAmplificationDisplay(gainValue) {
  const amplificationLevel = document.getElementById('amplificationLevel');
  amplificationLevel.textContent = `(${gainValue.toFixed(1)}ë°° ì¦í­)`;
}

function updateSafetyIndicator(gainValue) {
  const safetyIndicator = document.getElementById('safetyIndicator');
  if (gainValue >= 2.5) {
    safetyIndicator.style.backgroundColor = 'red';
  } else if (gainValue >= 2.0) {
    safetyIndicator.style.backgroundColor = 'orange';
  } else {
    safetyIndicator.style.backgroundColor = 'green';
  }
}

function startNoiseMonitoring() {
  const bufferLength = analyserNode.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  function updateNoiseLevel() {
    if (!isRunning || !analyserNode) return;
    
    analyserNode.getByteFrequencyData(dataArray);
    
    // ê°„ë‹¨í•œ ë…¸ì´ì¦ˆ ë ˆë²¨ ê³„ì‚°
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      sum += dataArray[i];
    }
    const average = sum / bufferLength;
    const noiseLevel = Math.round(20 * Math.log10(average / 255) + 60); // dB ë³€í™˜
    
    document.getElementById('noiseLevel').textContent = `${noiseLevel} dB`;
    
    requestAnimationFrame(updateNoiseLevel);
  }
  
  updateNoiseLevel();
}

function updateFilterEffectiveness() {
  const powerFilterEnabled = document.getElementById('powerNoiseFilter').checked;
  const highFreqFilterEnabled = document.getElementById('highFreqFilter').checked;
  
  let effectiveness = 0;
  if (powerFilterEnabled) effectiveness += 45; // 45% íš¨ê³¼
  if (highFreqFilterEnabled) effectiveness += 35; // 35% íš¨ê³¼
  
  document.getElementById('filterEffectiveness').textContent = `${effectiveness}% ê°ì†Œ`;
}

// Page Visibility API (ê°œì„ ë¨)
document.addEventListener('visibilitychange', async () => {
  if (document.hidden && isRunning) {
    // ë°±ê·¸ë¼ìš´ë“œë¡œ ì „í™˜ ì‹œ ì¼ì‹œì •ì§€
    wasRunningBeforeHidden = true;
    if (audioContext && audioContext.state === 'running') {
      try {
        await audioContext.suspend();
        console.log('AudioContext suspended (background)');
        statusDiv.textContent = 'â¸ï¸ ë°±ê·¸ë¼ìš´ë“œ ì¼ì‹œì •ì§€ ì¤‘...';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      } catch (err) {
        console.error('Background suspend failed:', err);
      }
    }
  } else if (!document.hidden && wasRunningBeforeHidden && isRunning) {
    // í¬ê·¸ë¼ìš´ë“œë¡œ ë³µê·€ ì‹œ ì¬ê°œ
    if (audioContext && audioContext.state === 'suspended') {
      try {
        await audioContext.resume();
        console.log('AudioContext resumed (foreground)');
        statusDiv.textContent = 'ğŸ”Š ë³´ì²­ê¸° ì‘ë™ ì¤‘ (ì´ì–´í° ì°©ìš© ê¶Œì¥)';
        statusDiv.style.background = '#d4edda';
        statusDiv.style.color = '#155724';
      } catch (err) {
        console.error('Foreground resume failed:', err);
      }
    }
    wasRunningBeforeHidden = false;
  }
});

// ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ (ê°œì„ ë¨)
async function checkAudioHealth() {
  if (isRunning && audioContext) {
    if (audioContext.state === 'suspended') {
      console.log('AudioContext suspended, attempting resume...');
      try {
        await audioContext.resume();
        console.log('AudioContext resumed successfully');
      } catch (err) {
        console.error('Failed to resume AudioContext:', err);
        statusDiv.textContent = 'âš ï¸ ì—°ê²° ë³µêµ¬ ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”';
        statusDiv.style.background = '#fff3cd';
        statusDiv.style.color = '#856404';
      }
    }
  }
}

// 5ì´ˆë§ˆë‹¤ ìƒíƒœ ì²´í¬
setInterval(checkAudioHealth, 5000);

// í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬ (ê°œì„ ë¨)
window.addEventListener('beforeunload', async () => {
  if (microphoneStream) {
    microphoneStream.getTracks().forEach(track => track.stop());
  }
  if (audioContext && audioContext.state !== 'closed') {
    try {
      await audioContext.suspend();
    } catch (err) {
      console.error('Beforeunload suspend failed:', err);
    }
  }
  if (wakeLock) {
    wakeLock.release();
  }
});

// ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ìë™ ì¬ê°œ (ê°œì„ ë¨)
let resumeAudioContext = async () => {
  if (audioContext && audioContext.state === 'suspended') {
    try {
      console.log("AudioContext state before resume:", audioContext.state);
      await audioContext.resume();
      console.log("AudioContext state after resume:", audioContext.state);
    } catch (err) {
      console.error("AudioContext resume failed:", err);
    }
  }
}

document.addEventListener('click', resumeAudioContext);
document.addEventListener('touchstart', resumeAudioContext); // ëª¨ë°”ì¼ ì§€ì›

// ì´ˆê¸°í™”: í˜ì´ì§€ ë¡œë“œ ì‹œ ë§ˆì´í¬ ëª©ë¡ í™•ì¸
setTimeout(async () => {
  if (hasPermission) {
    await updateMicrophoneList();
  }
}, 100);
</script>
</body>
</html>